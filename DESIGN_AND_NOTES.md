# CarePlus Pharmacy – Design Decisions & Notes

This document captures design decisions, edge cases, and implementation notes for the CarePlus Pharmacy application (aligned with the project rule to maintain such a document as implementation progresses).

---

## Design Decisions

### Architecture

- **Backend**: Ports & adapters (hexagonal) style. Domain lives in `internal/domain` (models + services). Ports: `inbound` (service interfaces), `outbound` (repositories, auth provider). Adapters: HTTP handlers, GORM persistence, JWT auth.
- **Single pharmacy per user**: Users have a `pharmacy_id`; JWT carries `user_id`, `pharmacy_id`, and `role`. All product/order/payment operations are implicitly scoped to the user’s pharmacy.
- **No separate “account” entity**: Unlike the parent a-OK Enterprise app, CarePlus uses Pharmacy as the top-level tenant; users belong to one pharmacy with roles (admin, pharmacist, staff).

### Data model

- **Pharmacy**: id, name, license_no, **tenant_code**, **hostname_slug**, **business_type** (pharmacy, retail, clinic, other), address, phone, email, is_active.
- **User**: id, pharmacy_id, email, password_hash, name, role, **points_balance** (int, default 0; pharmacist/staff points earned from completed sales), is_active. **Roles**: admin, manager, pharmacist, staff. **Pharmacist profile** (optional, used when role is pharmacist): license_number, qualification, cv_url, photo_url, date_of_birth, gender, phone. Stored on User; create/update user API accept these when role is pharmacist. Add-user form shows pharmacist details section (license, qualification, CV upload, photo upload, DOB, gender, phone) when role is Pharmacist; files are uploaded via `POST /upload` then URLs sent in create body.
- **UserAddress**: id, user_id, label, line1, line2, city, state, postal_code, country, phone, is_default. Per-user delivery/billing addresses; one can be marked default. Used in profile settings; first address is auto-set as default.
- **Product**: id, pharmacy_id, name, description, sku, category (string, denormalized name for filter; synced from Category when category_id set), **category_id** (optional FK to Category — product type = category + subcategory; when set, category_detail and parent are known), unit_price, **discount_percent** (0–100; when > 0, unit_price is the sale price; API and UI show “X% off” and original price derived as unit_price/(1−discount_percent/100)), currency, stock_quantity, unit, requires_rx, is_active, expiry_date, manufacturing_date, brand, barcode, storage_conditions, dosage_form, pack_size, generic_name, **hashtags** (JSONB), **labels** (JSONB). API returns **category_detail** (id, name, parent: { id, name }) when category_id is set. Batch-level expiry remains on InventoryBatch (FEFO).
- **Order**: id, pharmacy_id, order_number, customer_*, **customer_id** (nullable FK to Customer), **referral_code_used**, **points_redeemed**, status, sub_total, total_amount, currency, notes, created_by.
- **OrderItem**: id, order_id, product_id, quantity, unit_price, total_price.
- **Customer**: id, pharmacy_id, name, phone, email, **referral_code** (unique per pharmacy, 8-char), **points_balance**, **referred_by_id** (nullable FK to Customer). Identified by (pharmacy_id, phone); created or linked on first order for referral and points.
- **PointsTransaction**: id, customer_id, amount (+ earn / − redeem), type (earn_purchase | earn_referral | redeem), order_id, referral_customer_id (for earn_referral). Ledger for audit.
- **ReferralPointsConfig**: id, pharmacy_id, points_per_currency_unit, currency_unit_for_points, referral_reward_points, redemption_rate_points, redemption_rate_currency, max_redeem_points_per_order (0 = no cap). Per-pharmacy rules; if missing, referral/points are disabled.
- **StaffPointsConfig**: id, pharmacy_id, points_per_currency_unit, currency_unit_for_points. Per-pharmacy rules for **pharmacist/staff points** earned when an order is marked **completed**; the user who created the order (`created_by`) is credited with floor(total_amount / currency_unit) × points_per_unit. If no config exists, GetOrCreateByPharmacyID creates default (1 point per 100 NPR). Used so pharmacists can see earned points in Profile.
- **Payment**: id, order_id, pharmacy_id, **payment_gateway_id** (optional FK), amount, currency, method, status, reference, paid_at, created_by. **PaymentMethod** includes wallet, qr, cod, fonepay (for gateway-based checkout).
- **PaymentGateway**: id, pharmacy_id, code (esewa, khalti, qr, cod, fonepay, etc.), name, is_active, sort_order. Managed per pharmacy; active gateways are shown at checkout. Mock payment: when an order is created with `payment_gateway_id`, a payment record is created and completed immediately (no real gateway call).
- **Invoice**: id, pharmacy_id, order_id, invoice_number (unique per pharmacy), status (draft, issued), issued_at, created_by. One invoice per order; created from an order via `POST /orders/:orderId/invoices`. Draft can be issued via `POST /invoices/:id/issue`.
- **PharmacyConfig**: id, pharmacy_id (unique), display_name, location, logo_url, banner_url, tagline, contact_phone, contact_email, primary_color, default_language, **website_enabled** (bool: company website on/off), **feature_flags** (JSONB map: feature key → enabled, e.g. products, orders, chat), license_no, verified_at, established_year, return_refund_policy. One row per pharmacy for website branding and media. When `verified_at` is set, the public store shows a "Verified pharmacy" badge. Custom return/refund policy is shown on the public Return & Refund page when set; otherwise a default compliant policy is displayed.
- **Category**: id, pharmacy_id, **parent_id** (nullable; nil = top-level, set = subcategory), name, description, sort_order. **GET /categories?parent_id=** returns children when set. Products link via category_id; API returns category_detail with parent.
- **ProductUnit**: id, pharmacy_id, name, description, sort_order. Per-pharmacy units of measure (e.g. tablet, bottle, box, ml). Maintained by the pharmacist like Category; product form can use product-units list for the unit dropdown; products keep `unit` as a string.
- **Membership**: id, pharmacy_id, name, description, discount_percent (0–100), is_active, sort_order. Per-pharmacy loyalty tiers — names and details are dynamic (defined via API/UI, no fixed tier list). **CustomerMembership**: id, customer_id, membership_id. Links a customer to a tier; when an order is placed with a customer_phone that matches a customer with a membership, the membership discount is applied to the order (before promo code). Admin can assign customers to tiers via customer_memberships.
- **Promo**: id, pharmacy_id, type (offer | announcement | event), title, description, image_url, link_url, start_at, end_at, sort_order, is_active. Per-pharmacy promotional content shown on the public store (ads-style banners). Used for offers, announcements, and events to inform users.
- **Announcement**: id, pharmacy_id, type (offer | status | event), template (celebration | banner | modal), title, body, image_url, link_url, display_seconds (1–30), valid_days, show_terms, terms_text, allow_skip_all, start_at, end_at, sort_order, is_active. Per-pharmacy announcements shown as **dashboard popups** to end users (and staff). Pharmacist/admin/manager create announcements from the sidebar “Announcements” page; users see them on the dashboard with Skip / OK / “Skip all” (optional). Once acknowledged or skipped, they are not shown again; “Skip all” hides all announcements for 24h.
- **AnnouncementAck**: id, user_id, announcement_id (nullable when skip_all=true), acknowledged_at, skip_all. Tracks which announcements a user has dismissed; when skip_all is true, no announcement is shown to that user for 24h.
- **DutyRoster**: id, pharmacy_id, user_id (pharmacist), date, shift_type (morning | evening | full), notes. Manager/admin assigns pharmacists to shifts by date.
- **DailyLog**: id, pharmacy_id, date, title, description, status (open | done), created_by. Manager/admin creates daily tasks (e.g. opening checklist, closing tasks); status can be toggled.

Orders and payments use string status enums (e.g. pending, confirmed, completed) for simplicity; value objects can be introduced later if needed.

- **Order status flow**: Order statuses are `pending` → `confirmed` → `processing` → `ready` → `completed`, with `cancelled` allowed from pending/confirmed/processing/ready. Completed and cancelled are terminal. The backend enforces valid transitions in `UpdateStatus`; invalid transitions return `VALIDATION_ERROR`.
- **Order.CompletedAt**: When an order’s status transitions to `completed`, `CompletedAt` is set so that (1) **reviews** are allowed only within **7 days** of completion, and (2) **return requests** are allowed only within **3 days** of completion.
- **Product reviews (7-day window)**: End users can review a product only if they purchased it in a **completed** order and that order was completed within the last **7 days**. The review service checks `GetLatestCompletedOrderWithProduct` and rejects with a clear validation message otherwise. Product detail page shows the hint “You can review within 7 days of order completion.”
- **Return request (3-day window, defect)**: After completion, the order creator can submit a **return request** within **3 days**, with **video** (optional), **photos** (at least one if no video), **notes**, and **description**. Model `OrderReturnRequest` (order_id, user_id, status pending/approved/rejected, video_url, photo_urls JSON, notes, description). API: `POST /orders/:orderId/return-request`, `GET /orders/:orderId/return-request`. Files are uploaded via existing `POST /upload`; URLs are sent in the create body. Order detail page shows the “Return request (defect)” section for completed orders; form is shown only when within 3 days and no request exists yet.
- **Order accept**: `POST /api/v1/orders/:orderId/accept` accepts a pending order (sets status to `confirmed`). Only pending orders can be accepted; otherwise returns validation error. Both Accept and `PATCH /orders/:orderId/status` return the updated order so the UI can refresh without refetching the list.
- **End-user (role "staff") order visibility and actions**: End users (buyers) see only **their own** orders: `GET /orders` is filtered by `created_by = user_id` when the JWT role is `staff`. `GET /orders/:orderId` returns 403 if the order’s `created_by` does not match the current user when role is `staff`. End users **cannot** accept orders or update order status: `POST /orders/:orderId/accept` and `PATCH /orders/:orderId/status` return 403 with a clear message for role `staff`. Dashboard stats `orders_count` for role `staff` reflects only that user’s order count. Frontend: Orders page uses `useAuth()`; when `user.role === 'staff'` the page title is "My orders", the Actions column (Accept, Change status, Invoice) is hidden, and the API enforces the same restrictions.
- **Invoices**: Create from order (`POST /orders/:orderId/invoices`); list (`GET /invoices`); get full view (`GET /invoices/:id` returns invoice + order + items + payments); issue draft (`POST /invoices/:id/issue`). Creating an invoice for an order that already has one returns `CONFLICT`.

### API design

- REST over JSON. Auth: Bearer token from login/refresh. Protected routes read `pharmacy_id` from middleware (JWT) so handlers don’t take it from body/path for write operations.
- **Public store API**: Products and pharmacies are visible without login. Routes under `/api/v1/public/`: `GET /public/pharmacies`, `GET /public/pharmacies/:pharmacyId`, `GET /public/pharmacies/:pharmacyId/config`, `GET /public/pharmacies/:pharmacyId/products`, `GET /public/pharmacies/:pharmacyId/categories`, `GET /public/pharmacies/:pharmacyId/promos` (offers, announcements, events; optional `?type=offer,announcement,event`), `GET /public/pharmacies/:pharmacyId/payment-gateways` (active gateways for checkout), `GET /public/products/:id`. Add-to-cart and place-order require login (protected `/orders` and cart state in frontend).
- **Product catalog API**: `GET /public/pharmacies/:pharmacyId/products` supports catalog params: `q` (search on name, description, SKU, brand, generic_name; ILIKE), `sort` (name|price_asc|price_desc|newest), `category`, `in_stock`, `hashtag`, `brand`, `label_key`, `label_value`, `limit`, `offset`. When `q`, `sort`, or any of hashtag/brand/label is present, the backend uses catalog listing (active products only). Catalog response items include optional `rating_avg` and `review_count` (aggregated from product reviews). Repository: `ListByPharmacyCatalog(..., filters *CatalogFilters)`; service: `ListCatalog(..., filters)`.
- **Product QR and barcode**: Products have an optional `barcode` field (indexed). `GET /api/v1/products/by-barcode/:barcode` (auth required) returns the product for the current pharmacy with that barcode; 404 if not found. Used for barcode lookup and scanning. QR codes encode the product UUID so scanners or internal tools can resolve the product via `GET /products/:id`. Frontend: Products page has a “Lookup by barcode” input, an “Actions” column with “QR/Barcode” per row, and a modal that shows QR code (qrcode.react) and barcode image (react-barcode) when set.
- **Pharmacy config API**: Protected `GET /config` (get-or-create for current pharmacy), `PUT /config` (upsert). Public `GET /public/pharmacies/:pharmacyId/config` for website banner, logo, name, location, etc.
- **App-config API (multi-tenant by hostname)**: Public `GET /api/v1/app-config` (no auth) returns tenant app config based on the request hostname. Used so each company can have its own website: the hostname (or short name) in the URL identifies the tenant. Query `?hostname=careplus` can override for dev. Response: `company_name`, `default_theme`, `language`, `address`, `tenant_code`, `pharmacy_id`, **`business_type`** (pharmacy, retail, clinic, other), **`website_enabled`** (company website on/off), **`features`** (map of feature keys to boolean: products, orders, chat, promos, referral, memberships, billing, announcements, inventory, statements, categories, reviews), plus optional `logo_url`, `tagline`, `contact_phone`, `contact_email`, `verified_at`. Backend normalizes Host and looks up `pharmacies.hostname_slug`; then returns merged pharmacy + pharmacy_config. Frontend: when not logged in, `BrandContext` loads app-config and sets `websiteEnabled` and `features`; if `website_enabled` is false, public pages show "Website temporarily unavailable". Dashboard sidebar entries are filtered by `features` so admins can disable whole areas per company.
- **Dashboard stats API**: Protected `GET /api/v1/dashboard/stats` returns counts for the current pharmacy: `orders_count`, `products_count`, `pharmacists_count`, `today_roster_count`, `today_dailies_count`. For non-manager roles, manager-only fields are 0. Used by the dashboard page so one request loads all stats; products count uses `ListPaginated(limit=1)` for total only.
- **Role-based access control (RBAC)**  
  JWT carries `role`: `admin`, `manager`, `pharmacist`, `staff` (end-user/buyer). Middleware: `RequireAdmin()` (admin only), `RequireAdminOrManager()` (admin or manager), `RequireStaffRole()` (admin, manager, or pharmacist — excludes buyer).  
  - **Any authenticated user**: Dashboard stats, notifications (list/count/read), pharmacies (list/get), orders (create, list, get — handler restricts staff to own orders only), promo-codes validate (checkout), reviews (list/get/create/update/delete, like, comments).  
  - **Staff role only** (admin/manager/pharmacist): Upload; products (full CRUD, images, batches list, reviews); categories; product-units; memberships; inventory (list batches, expiring, get batch); referral (get config, customers, redeem-preview); orders accept/update status/create invoice; promo-codes CRUD (create/list/get/update); invoices; payments; payment-gateways (list/get).  
  - **Admin or Manager only**: Users (list/create/get/update/deactivate — admin: all roles; manager: pharmacists only), duty roster, daily logs, inventory batch write (add/update/delete batches).  
  - **Admin only**: Pharmacy create/update, config get/upsert, notifications create, activity list, promos (offers/events) CRUD, referral config upsert, payment-gateways create/update/delete.
  - **Staff (admin/manager/pharmacist)** also: announcements CRUD (create/update/delete announcements shown as dashboard popups).  
  - **Registration**: `POST /auth/register` accepts only `role: "staff"`; any other role returns 403. Admin/manager/pharmacist accounts are created by existing admins/managers via the users API.
- Error responses: `{ code, message }` with HTTP status reflecting the error type (4xx/5xx). For validation errors (400), the API may return `{ code, message, fields }` where `fields` is a map of field names (snake_case, e.g. `email`, `pharmacy_id`, `name`, `sku`) to error messages so the UI can show inline field-level errors.
- **Activity and audit logs**: Each authenticated API request is logged by middleware (action = method + path, **description** = human-readable message from a path map, e.g. "Viewed orders", "User logged in"). The **Activity** model has `action`, `description`, `entity_type`, `entity_id`, and `details` (JSON). For **edit, delete, login, logout, enable/disable, and config change**, handlers write an additional audit entry with **details** describing what changed (e.g. user update: `{ "user_id", "changes": { "is_active", "role" } }`; config: company_name, theme, etc.). Login is logged in the auth handler (no middleware on that route); **logout** is logged via `POST /auth/logout` (protected); frontend calls `authApi.logout()` before clearing tokens so the backend can record the event. **Activity page** (`/activity`, admin-only): table shows Time, User, **Description** (or action fallback), IP; clicking a row expands to show full details: action (API), entity type/ID, IP, and formatted **Changes / details** JSON for audit entries.
- **Profile addresses**: Authenticated users can manage their own addresses under `/auth/me/addresses`: `GET` (list), `POST` (create with optional set_as_default), `PUT /:id` (update), `DELETE /:id`, `PATCH /:id/default` (set default). Service ensures ownership; first address is auto-default; clearing default on delete promotes another.
- **End-user profile (rewards, referral, membership)**: For end users (role `staff` / buyer), profile shows **Rewards & referral**: QR code (encoding referral code), referral code with copy/share, points balance, points earned from purchases (sum of `earn_purchase` transactions), and membership details when the customer has an active membership. **Linking**: The logged-in user is matched to a **Customer** by `user.phone` and current pharmacy; when the user has a phone set, `GET /auth/me/customer-profile` **get-or-creates** a Customer (by pharmacy + phone) so each user has one referral code to share even before first order. When someone uses that code at checkout and completes their first order, the referrer gets reward points (from config). The response returns customer, membership (id, name), `points_earned_from_purchases`, and recent `points_transactions`. If no phone or no customer found, the response has `customer: null` and the frontend shows a hint to add the same phone number used when ordering. **Design decisions**: (1) User.Phone is optional and used only for buyer–customer linking; (2) QR encodes the referral code so others can type or scan it at checkout; (3) Share uses Web Share API when available, else copy link (catalog URL with `?ref=CODE`); (4) Points “earned from purchases” is computed server-side as the sum of positive `earn_purchase` transaction amounts for audit clarity.
- **Validation (required/optional)**: Request DTOs use `binding` tags (go-playground/validator) for required fields and rules (e.g. `required`, `email`, `min=6`, `gte=0`, `lte=100`). Handlers use `response.BindValidationError()` so validation failures return structured `fields` (snake_case keys) for the UI. Required vs optional is aligned: auth (email, password required; name, role optional); product (name, sku, unit_price required; description, category, dates, etc. optional); pharmacy (name, license_no required); category (name required); order (items required); membership (name required, discount_percent 0–100). Frontend: forms (Login, Register, Add Product) show required (*) and optional labels, run client-side validation matching API rules, and display API field errors inline via `ApiError.fields`.
- **Categories API**: Protected `GET /api/v1/categories` (list all by pharmacy) or `GET /api/v1/categories?parent_id=UUID` (list children of parent; omit for top-level). `POST`/`PUT` accept optional **parent_id** for subcategories. Used by the dashboard “Categories” page (parent picker in Add/Edit) and by the product form (parent → subcategory dropdowns for product type).
- **Product Units API**: Protected `GET /api/v1/product-units` (list by pharmacy), `POST /api/v1/product-units`, `GET /api/v1/product-units/:id`, `PUT /api/v1/product-units/:id`, `DELETE /api/v1/product-units/:id`. Per-pharmacy units of measure (e.g. tablet, bottle, box, ml), maintained by the pharmacist like categories. Used by the product form unit dropdown; products keep `unit` as a string that can match a product unit name.
- **Memberships API**: Protected `GET /api/v1/memberships` (list by pharmacy), `POST /api/v1/memberships`, `GET /api/v1/memberships/:id`, `PUT /api/v1/memberships/:id`, `DELETE /api/v1/memberships/:id`. Per-pharmacy membership tiers (name, description, discount_percent, is_active, sort_order). Validation: name required; discount_percent 0–100. Used by the dashboard “Memberships” page.
- **Promos API (offers, announcements, events)**: Public `GET /api/v1/public/pharmacies/:pharmacyId/promos` returns active promos for that pharmacy (optional `?type=offer,announcement,event`). Only promos with `is_active=true` and current time within `start_at`/`end_at` are returned. Admin-only: `GET /promos`, `POST /promos`, `GET /promos/:id`, `PUT /promos/:id`, `DELETE /promos/:id`. Body: type (offer|announcement|event), title (required), description, image_url, link_url, start_at, end_at (RFC3339), sort_order, is_active. Frontend: public products page shows a “What’s on” section (horizontal scroll of promo cards); dashboard “Offers & events” page (`/promos`) for admin CRUD.
- **Announcements API (dashboard popups)**: Any authenticated user: `GET /announcements/active` returns announcements to show on the dashboard (not yet acked, within start/end and valid_days; empty if user has “skip all” in last 24h). `POST /announcements/:id/ack` with body `{ "skip_all": false }` dismisses one announcement; `{ "skip_all": true }` records “skip all”. `POST /announcements/skip-all` records “skip all” (no id). Staff (admin/manager/pharmacist): `GET /announcements` (optional `?active=true`), `GET /announcements/:id`, `POST /announcements`, `PUT /announcements/:id`, `DELETE /announcements/:id`. Create/update body: type (offer|status|event), template (celebration|banner|modal), title (required), body, image_url, link_url, display_seconds (1–30), valid_days, show_terms, terms_text, allow_skip_all, start_at, end_at (RFC3339), sort_order, is_active. Frontend: sidebar “Announcements” for staff; dashboard page renders `AnnouncementPopups` which fetches active list and shows one-by-one with celebration/banner/modal templates, Skip / OK / Skip all, and optional terms.
- **Referral & points API**: Public `GET /api/v1/public/pharmacies/:pharmacyId/referral/validate?code=XXX` validates a referral code (returns valid, name). Protected: `GET /referral/config` (get-or-create with defaults), admin `PUT /referral/config` (upsert rules). `GET /customers` (paginated), `GET /customers/by-phone?phone=XXX`, `GET /customers/:customerId/points` (points history), `GET /referral/redeem-preview?customer_id=...&points_to_redeem=...&sub_total=...` (for checkout UI). Order create accepts optional `referral_code` and `points_to_redeem`; backend get-or-creates customer by phone, applies referral and points discount, and on order completion credits earn_purchase and (if first completed order) earn_referral; redeem is applied at order create and recorded in PointsTransaction.
- **Product reviews, like, comment and feedback**: Any authenticated user can leave a review (rating 1–5, optional title, body) per product; one review per user per product. Public: `GET /public/products/:productId/reviews` lists reviews (no auth). Auth: `POST /products/:id/reviews` (create), `GET /reviews/:id`, `PUT /reviews/:id`, `DELETE /reviews/:id`, `POST /reviews/:id/like`, `DELETE /reviews/:id/like`, `GET /reviews/:id/comments`, `POST /reviews/:id/comments`, `DELETE /comments/:id`. Reviews include like_count, user_liked (when auth), comment_count. Frontend: product detail page `/products/:id` shows product info, reviews list, “Write a review” form (auth), like button, and expandable comments with add-comment (auth).
- **Order feedback**: End users (the person who placed the order) can submit feedback on **completed** orders. One feedback per order. Auth: `GET /orders/:orderId/feedback` (returns feedback or null; same visibility as order—staff see only own), `POST /orders/:orderId/feedback` (body: `rating` 1–5 required, `comment` optional). Only the order creator can submit; order must be completed; duplicate submission returns CONFLICT. Frontend: order detail page shows a “Your feedback” section for the order owner when status is completed—rating stars + optional comment form, or “Thank you for your feedback” with submitted rating/comment.
- **Blog & Articles (medical terms, research, findings)**: Company and pharmacists can write blogs (medical terms in simple language, research findings, issues and articles). **Workflow**: Posts are created as **draft** or **pending_approval**; only **manager or admin** can **approve** (publish). Published posts are visible to all; draft/pending only to author and staff. **Models**: BlogPost (title, slug, excerpt, body, status, category_id, author_id, pharmacy_id), BlogCategory (name, slug, parent_id, sort_order), BlogPostMedia (image/video URL, caption), BlogPostLike, BlogPostComment, BlogPostView (for analytics). **API**: Protected `GET/POST /blog/categories`, `GET/PUT/DELETE /blog/categories/:id` (staff); `GET /blog/posts` (optional status, category_id; default published), `GET /blog/posts/pending` (admin/manager only), `POST /blog/posts` (staff; draft or pending_approval), `GET/PUT/DELETE /blog/posts/:id`, `POST /blog/posts/:id/approve` (admin/manager), `POST /blog/posts/:id/submit` (author submit draft for approval), like/unlike, comments CRUD, `POST /blog/posts/:id/view`, `GET /blog/posts/:id/analytics`, `GET /blog/analytics`. Public (no auth): `GET /public/pharmacies/:pharmacyId/blog/posts`, `GET /public/pharmacies/:pharmacyId/blog/posts/:slug`. **Frontend**: Sidebar “Blog & Articles” (staff: All posts, Categories, Write post, Pending approval [manager only], Analytics); buyers see single “Blog” link. Pages: list (filters: published/draft/pending, category), detail (sidebar with photos/videos, like, comments), create/edit (title, excerpt, body, category, status, media URLs), categories CRUD, pending (approve button), analytics (views, likes, comments per post). EN/NE translations for blog nav and labels.
- **File upload (photos/files)**: `POST /api/v1/upload` (auth required). Multipart form with field `file` or `photo`. Max 10 MiB. Allowed types: images (jpeg, png, gif, webp, svg), PDF, Word. Response: `{ "url": "...", "path": "...", "filename": "..." }`. Storage backend is chosen by **FS_TYPE**: `local` (default) or `s3`.
  - **FS_TYPE=local**: Files saved under `FS_LOCAL_BASE_DIR` (default `./data/images`). Served at `FS_LOCAL_BASE_URL` (default `/data/images`). Set in `.env`: `FS_TYPE=local`, `FS_LOCAL_BASE_DIR=./data/images`, `FS_LOCAL_BASE_URL=/data/images`. Product images are stored under `data/images/photos/products/<productId>/<year>/<month>/<uuid>.<ext>`. Backend serves static files at `LocalBaseURL` from `LocalBaseDir`; returned `url` is a path (e.g. `/data/images/photos/...`) usable when frontend and API share origin or when the frontend proxies image paths to the API.
  - **FS_TYPE=s3**: Files stored in the configured S3 (or MinIO) bucket. Env: `S3_BUCKET`, `S3_REGION`, `S3_ACCESS_KEY`, `S3_SECRET_KEY`; optional `S3_ENDPOINT` for MinIO. Returned `url` is path-style (`/bucket/key`); frontend or CDN may need to prepend base URL or use presigned URLs for public read.
  - **Frontend image display**: Product image URLs from the API are relative (e.g. `/data/images/photos/...` or legacy `/uploads/...`). Vite dev server proxies `/data/images` and `/uploads` to the backend so images load. All product image `<img src>` use `resolveImageUrl(url)` from `lib/api.ts`; when `VITE_API_ORIGIN` is set (e.g. in production with API on another host), relative URLs are resolved against it so images display correctly.

### Frontend

- React 18, Vite, TypeScript, Tailwind. Single SPA with React Router. Auth stored in context + localStorage (access token); optional refresh token support can be added.
- **Public website (explore) / Product catalog**: Route `/products` is the main unauthenticated product catalog: header (logo, Products, Register, Login), footer (copyright, links), and product grid. Visiting the site root `/` when not logged in redirects to `/products`. The catalog includes: pharmacy selector (if multiple), **search bar** (debounced; searches name, description, SKU, brand, generic name), **category dropdown** (from `GET /public/pharmacies/:pharmacyId/categories`), **sort** (Name A–Z, Price low–high, Price high–low, Newest first), **In stock only** toggle, and **Clear filters**. Pagination and product cards unchanged; “Add to cart” disabled for out-of-stock; “Add to cart” and “Place order” require login (`returnTo=/products`). Cart is client-side (CartContext); orders use protected `orderApi.create`. When logged in, header shows Dashboard, Cart, user email, Logout. `/login` and `/register` use the same `WebsiteLayout`. Catch-all route `*` sends guests to `/products`.
- **End-user login console**: Login page is restructured for a clearer, user-friendly flow: (1) Centered hero with icon and welcoming title/subtitle; (2) Single sign-in card with email/password, placeholders, show/hide password toggle, and “Forgot password?” link (placeholder for future flow); (3) Register and “Back to products” as secondary actions; (4) Demo accounts in a collapsible “Try demo accounts” section so regular users see a clean form first. Translations added for placeholders, show/hide password, forgot password, and try-demo label (EN + NE). Accessibility: form `noValidate` with client + API validation, `aria-invalid`/`aria-describedby` on fields, `role="alert"` on error, focus styles on interactive elements. Staff product management (table) lives at `/manage/products` (protected).
- **Enterprise dashboard and profile UI**: Sidebar: wider (w-64), clear nav with rounded links and hover/active states; brand block; sidebar footer with user avatar, name, email, Profile and Log out. Header: profile button with avatar + name/email + chevron; dropdown with Profile settings and Log out. Dashboard home: welcome with user name; stat cards as links with icon badges; Quick actions grid. Profile settings: theme-aware cards and forms; Account, Change password, Addresses sections; full EN/NE translations. Website: logged-in users get avatar dropdown (Dashboard and Profile for dashboard roles only; Log out for all).
- API client: single `api()` helper that adds base path and Authorization header; typed API functions and shared types in `lib/api.ts`. Public store uses `publicStoreApi` (same base, no token required).
- **Categories**: Sidebar includes “Categories” (`/manage/categories`). Table lists name, description, sort order; Add/Edit modal (name, description, sort order); delete with confirmation. Product form category field: if categories exist, a dropdown lists them plus “Other (type below)” for custom text; otherwise a plain text input.
- **Memberships (dynamic tiers)**: Tiers are fully dynamic: backend stores per-pharmacy memberships (name, description, discount_percent, is_active, sort_order) with no fixed tier names. API: `GET/POST/PUT/DELETE /api/v1/memberships` (list by pharmacy from JWT). UI: “Memberships” (`/manage/memberships`) loads tiers from the API, table lists name, description, discount %, active, sort order; Add/Edit modal creates or updates tiers. Used to define loyalty tiers (any names the pharmacy chooses) with optional member discount; assign tiers to customers and apply discount at checkout.
- **Add Product**: Products page (`/manage/products`) has a 5-step “Add Product” modal: (1) **Details** — name, SKU (required), description, **Category / Product type** (optional: parent category dropdown → subcategory dropdown; selecting a category/subcategory sets category_id so the product knows its parent); (2) **Images** — add at least one image; (3) **Pricing & Stock** — unit price, **discount %** (0–100; when set, unit price is sale price), currency, stock quantity, unit; (4) **Dates & Properties** — manufacturing/expiry dates, brand, barcode, dosage form, pack size, generic name, storage, requires prescription, active; (5) **Review & Submit** — full review summary, then “Add Product”. API returns **category_detail** (with parent) so the products table and product detail page show “Parent > Subcategory” or category name.
- **Product card tags (catalog / explore)**: Product cards on the public catalog show optional badges: **discount %** (e.g. “15% off” when discount_percent > 0), **Low stock** (when stock_quantity ≤ 10 and > 0), and **New** (when product was created in the last 30 days, using created_at). When discount is set, the card shows original price (strikethrough) and sale price (unit_price). Same discount/original-price display on product detail page.
- **Product images**: Products support multiple images with a primary image. Backend: `ProductImage` model (product_id, url, is_primary, sort_order); `POST /products/:id/images` (multipart file + optional `is_primary`), `PATCH /products/:id/images/:imageId/primary`, `DELETE /products/:id/images/:imageId`. Images are stored via existing `FileStorage` (local or S3). Product Get/List preload `Images`. In Add Product step 4, after the user clicks “Create Product”, the image upload UI is shown; the user must add at least one image before “Done” is enabled. Product list table and store/explore product cards show the primary image; cart and order flows show product thumbnails. Order repository preloads `Product.Images` when loading order items.
- **Product QR and barcode (UI)**: On the Products page (`/manage/products`): (1) “Lookup by barcode” input in the header—enter a barcode and click Lookup (or press Enter) to fetch the product and open the QR/Barcode modal. (2) Each row has an “Actions” column with a “QR/Barcode” button that opens a modal showing: QR code (encoding product ID via `qrcode.react`) and barcode image (via `react-barcode`) when the product has a barcode; otherwise “No barcode set”. QR codes can be printed or scanned to resolve the product; barcode is for standard barcode scanners.
- **Product list pagination (18+ products)**: To maintain many products without loading all at once, list endpoints support optional `limit` and `offset` query params. When `limit > 0`, the API returns `{ items: Product[], total: number }`; when omitted, it returns the full array (backward compatible). **API**: `GET /products?limit=10&offset=0` (protected) and `GET /public/pharmacies/:pharmacyId/products?limit=12&offset=0` (plus optional `q`, `sort`, `category`, `in_stock` for catalog) return paginated responses. Protected `GET /products` also accepts optional `q` (search on name, SKU, brand, generic_name); when `q` is present the handler uses `ListCatalog` with default sort and limit (e.g. 20) for Billing/dashboard search. **Repository**: `ListByPharmacyPaginated(...)` and `ListByPharmacyCatalog(..., searchQ, sort, limit, offset)` for catalog. **UI**: Dashboard Products page (`/manage/products`) uses `productApi.listPaginated()` with default 10 per page; Billing page uses `productApi.listPaginated({ q, limit: 20 })` for product search. Public Product catalog (`/products`) uses `publicStoreApi.listProductsPaginated()` with 12 per page, search/sort/category/in-stock filters. Both pages show “Page X of Y (N total)”.
- **Notifications**: Per-user notifications (title, message, type). API: GET/POST notifications, count unread, mark read, mark all read. Admin POST to create. Seed creates demo notifications for admin user. Frontend: Bell dropdown with unread count; /notifications page with mark-as-read.
- **Orders (clickable rows and detail)**: Orders list table rows are clickable and navigate to order detail (`/orders/:id`). The Actions column uses `stopPropagation` so Accept, Change status, and Invoice buttons do not trigger row navigation. Order detail page shows: back link to list, order number/customer/date, **order status timeline** (connected stepper: Pending → Confirmed → Processing → Ready → Completed with current step highlighted and past steps marked done; cancelled orders show a “Cancelled” state), and **order items** table. Each item’s product name is a link to the product page (`/products/:productId`). Staff (admin/manager/pharmacist) see Accept, Change status, and Create invoice on the detail page as on the list. Status timeline is derived from current order status (no backend status-history table); future enhancement could add OrderStatusHistory for per-step timestamps. **Order feedback**: When the viewer is the order creator and the order is completed, a “Your feedback” section appears—rating (1–5 stars), optional comment, and Submit; after submission the section shows “Thank you for your feedback” with the rating and comment.
- **Invoices**: Sidebar includes “Invoices” (`/invoices`). List shows invoice number, status (draft/issued), date; “View” opens invoice detail (`/invoices/:id`). Detail page shows bill-to, line items (from order), totals, and payments; “Issue invoice” button for drafts. Orders page has “Invoice” button to create an invoice from an order; on success navigates to the new invoice detail. Creating an invoice for an order that already has one shows the API error (e.g. “invoice already exists for this order”).
- **Checkout payment**: At checkout (cart drawer on Products explore and Store pages), the UI fetches active payment gateways via `GET /public/pharmacies/:pharmacyId/payment-gateways` and shows them as “Payment method” options. Order create accepts optional `payment_gateway_id`; when set, the backend creates a payment record for that gateway and marks it completed (mock payment). Gateways are managed in **Config** (`/config`): “Payment gateways” section lists gateways (code, name, active, sort order); admin can add (e.g. eSewa, Khalti, QR, Cash on Delivery, Fonepay), edit, or delete. Auth: `GET /payment-gateways` (list), `GET /payment-gateways/:id`; admin-only: `POST /payment-gateways`, `PUT /payment-gateways/:id`, `DELETE /payment-gateways/:id`.
- **Billing (POS)**: Sidebar includes “Billing” (`/billing`, Receipt icon). POS-style page: add items via **scan barcode** (`GET /products/by-barcode/:barcode`), **product ID** (UUID in search → `GET /products/:id`), or **name/SKU search** (`GET /products?q=...&limit=20`). Cart holds line items (product_id, quantity, unit_price); optional **customer** (phone lookup via `GET /customers/by-phone?phone=X` returns customer with optional **membership** `{ id, name }` and points balance). Optional **promo/voucher code** (validate via `POST /promo-codes/validate`), **manual discount**, and **redeem points** (preview via `GET /referral/redeem-preview`). “Generate bill” creates order → invoice → issues invoice; then optional “Record payment” modal (amount, method) creates and completes a payment. Protected `GET /products` accepts optional `q` for dashboard product search (uses ListCatalog when `q` present). QR scan: encode product UUID; on scan decode and call `GET /products/:id`.
- **Statements / Transactions**: Sidebar includes “Statements” (`/statements`, ListOrdered icon). Single page with tabs: **Orders**, **Payments**, **Invoices**. Data from existing `orderApi.list()`, `paymentApi.list()`, `invoiceApi.list()`. Optional **date range filter** (from / to) applied on the frontend. Tables show order number, date, customer, status, total (orders); date, order ref, amount, method, status (payments); invoice number, date, status with link to detail (invoices). “Print statement” opens a print window with aggregated summary (order count/total, payment count/total) and tables for the selected date range (frontend-only aggregation).
- **Profile addresses (end user)**: After login, users can add multiple addresses and choose a default from Profile settings (`/profile`). Addresses section: list with label, full address, default badge; Add address (label, line1, line2, city, state, postal_code, country, phone, set as default); Edit, Delete, and “Set as default” per address. Uses `addressesApi` (list, create, update, delete, setDefault).
- **Pharmacist points in profile**: Pharmacists (and any staff who create orders) earn points when an order is marked **completed**; points are based on order total and pharmacy **StaffPointsConfig** (e.g. 1 point per 100 NPR). `GET /auth/me` returns `points_balance`. Profile settings Account section shows **My points** with value and an **eye icon** to show/hide the number (toggle: eye = visible, eye-off = hidden; hidden state shows "••••••"). EN/NE translations for profile_points, profile_points_earned, profile_show_points, profile_hide_points.
- **Light/dark theme**: A `ThemeContext` provides `theme` ('light' | 'dark'), `setTheme`, and `toggleTheme`. Preference is persisted in `localStorage` (`careplus-theme`); initial value falls back to `prefers-color-scheme` when no stored value exists. The `dark` class is applied to `<html>` for dark mode so Tailwind's `dark:` variants and CSS variables (e.g. `--theme-bg`, `--theme-text`) switch smoothly. Semantic tokens in `index.css` and Tailwind (`theme.bg`, `theme.text`, `theme-surface`, `theme-muted`, etc.) give consistent, user-friendly colors and backgrounds in both modes. Theme toggle (sun/moon icon) is available in the dashboard header and in the public website header. Transitions (0.2s ease) on body and theme-aware elements avoid jarring switches.
- **Terms and Conditions / Privacy Policy (Nepal government)**: Registration requires the user to agree to Terms and Conditions and Privacy Policy. Content is aligned with the Government of Nepal **Electronic Transaction Act, 2063 (2006)** and **Privacy Act, 2075 (2018)**. Routes: `/terms`, `/privacy`. Register page includes a required “I agree” checkbox linking to both documents; submit is blocked until checked. Footer (WebsiteLayout) links to Terms and Privacy. Translations for titles and agree text exist in English and Nepali.
- **Return and Refund Policy**: Route `/return-refund` shows a compliant return and refund policy. Content is **API-driven**: public `GET /public/pharmacies/:pharmacyId/config` includes optional `return_refund_policy` (text). When set by the pharmacy (Configuration page), that text is shown; otherwise a default policy is displayed (English and Nepali) covering eligibility, timeframe (e.g. 7 days), process, refunds, non-returnable items, and contact, aligned with consumer protection and fair trade. Footer links to Return and Refund. Admin edits the policy in Config under “Return & Refund Policy”. BrandContext exposes `publicPharmacyId` so the policy page can fetch the selected pharmacy’s config when the user is browsing a specific store.
- **Branding consistency**: All pages use the same brand: display name, logo, and primary color from pharmacy config. A `BrandContext` fetches config when the user is logged in (`GET /config`) or, for public pages, from the first/selected pharmacy (`GET /public/pharmacies/:id/config`). CSS variables `--brand-primary` and `--brand-secondary` are set on `document.documentElement` so Tailwind’s `careplus-primary` / `careplus-secondary` reflect the configured color. Dashboard layout (sidebar) and website layout (header/footer) show logo (or Pill icon fallback) and display name; Configuration page updates apply immediately via `refreshBrand()`.
- **Dashboard header**: Top-right of the dashboard layout shows a notification bell (dropdown with “No new notifications” placeholder) and a profile avatar (initials from name/email). Avatar dropdown shows user name/email, “Profile settings” (links to `/profile`), and “Log out”. Click-outside closes both dropdowns.
- **Responsive sidebar**: On viewports below the `md` breakpoint, the dashboard sidebar is hidden by default and can be opened/closed. A hamburger (Menu) button in the header opens the sidebar; a close (X) button in the sidebar header and a semi-transparent backdrop (click to close) close it. Clicking any nav link or logout in the sidebar also closes it on mobile. On `md` and up, the sidebar is always visible in flow; the hamburger and backdrop are hidden.
- **Profile settings**: Route `/profile` (protected). Page shows email (read-only), role, and editable display name. `PATCH /api/v1/auth/me` with `{ name }` updates the current user’s name; AuthContext exposes `refreshUser()` so the header avatar and sidebar reflect the new name after save.
- **Loader component**: Reusable Care+ loader (`Loader.tsx`) with variants: `fullPage` (auth check, full viewport with “Care+” branding), `page` (main content area, centered spinner + message), `inline` (tables/cards, compact), `small` (dropdowns, buttons). Optional `style`: `spinner` (default) or `dots`. **Animations**: dual-ring spinner with smooth `loader-spin` (cubic-bezier), `fullPage` adds a subtle pulsing ring behind; dots use staggered bounce (`loader-dot`); wrapper uses `animate-fade-in-up` for entrance. Uses Care+ teal (`careplus-primary`), optional message, and `role="status"` / `aria-label` for accessibility. Used on auth route, Dashboard, Products, Orders, Invoices, Chat, Config, Products explore, Register, Store, etc.
- **Skeleton component**: Content placeholders (`Skeleton.tsx`) for loading states. Variants: `line` (single or multiple lines), `circle`, `rect`, `card`; composite helpers: `SkeletonProductCard`, `SkeletonTableRow`. Shimmer animation (`loader-shimmer`) sweeps a light gradient across skeleton blocks. Theme-aware (`bg-theme-border-subtle`, dark-mode via `before:via-white/10`). Use for lists, cards, or tables while data is loading to reduce perceived wait and layout shift.
- **Change password**: Same profile page includes a “Change password” section. User must provide current password, new password (min 6 chars), and confirmation. `PATCH /api/v1/auth/me/password` with `{ current_password, new_password }` (auth required) validates current password, hashes new one, and updates the user; returns 401 if current password is wrong. Frontend clears the form and shows success on success; validation errors (e.g. mismatch, too short) are shown inline.
- **Confirmations**: Update, delete, approve, and logout actions use a shared `ConfirmDialog` component so each has its own confirmation. Logout is confirmed in both dashboard Layout and public WebsiteLayout. Category delete and category update (when editing) use ConfirmDialog. Order accept (approve) and order status change (including cancel) are confirmed. Invoice issue is confirmed. Config save, profile save, and password change are confirmed. Variants: default (primary button), danger (red for delete/cancel), warning (amber) available.
- **Refresh**: Data-loading pages expose a refresh icon (RefreshCw) next to the page title so users can reload the list or config without leaving the page. Pages with refresh: Dashboard, Products, Categories, Orders, Invoices, Invoice detail, Payments, Notifications, Activity, Config, Pharmacy, and the public Products explore page.
- **Role-based sidebar**: Sidebar menu items are filtered by user role via `getVisibleNavEntries(role)` in `Layout.tsx`. Each nav entry can be a link or a group (e.g. Product Management with Products, Categories, Units, Catalog). Optional `roles` array: if absent, the entry is shown to all roles. **admin**: full access (Dashboard, Product Management, **Team**, **Duty Roster**, **Daily Logs**, Memberships, Customers, **Inventory**, Orders, **Billing**, Invoices, Payments, **Statements**, Promos, Notifications, Activity, Pharmacy, Configuration). **manager**: same as admin except no Promos, Activity, Pharmacy, Config. **pharmacist**: same product/membership/customers as manager plus **Inventory** (view only); no Team, Duty Roster, Daily Logs. **staff**: only Dashboard, Orders, Billing, Invoices, Payments, Statements, Notifications. Backend enforces access; sidebar only hides links the role is not intended to use.
- **Inventory (sidebar and list)**: **Inventory** appears in the sidebar for pharmacist, manager, and admin (`/inventory`, Boxes icon). All three roles can view the inventory list (batches by pharmacy with product name, batch number, quantity, expiry date). **Manager and admin** can add batches (modal: select product, batch number, quantity, expiry date), edit batch quantity/expiry, and delete batches; these write operations are restricted to admin or manager in the backend so that “inventory changes can be approved by the manager.” Pharmacist sees the list and a note that changes require manager approval; Add/Edit/Delete actions are hidden for pharmacist. Backend: `GET /inventory/batches` returns batches with Product preloaded; write routes (`POST /products/:id/batches`, `PATCH /inventory/batches/:batchId`, `DELETE /inventory/batches/:batchId`) are under `RequireAdminOrManager()`.
- **Inventory report export**: Inventory page has an **Export report** dropdown with **Export to Excel** and **Export to PDF**. **Excel** export produces a single `.xlsx` file with three sheets: **All Batches** (product, batch number, quantity, expiry date, created at), **Expiring Soon** (batches expiring within 30 days, same columns), and **By Product** (product name, total quantity, batch count). **PDF** export produces a single `.pdf` with the same three sections (title, generated date, then All Batches, Expiring Soon, By Product tables). Exports use current list data plus `GET /inventory/expiring?days=30` for the expiring-soon dataset; empty batches produce reports with empty tables. Dependencies: `xlsx` (SheetJS) for Excel, `jspdf` and `jspdf-autotable` for PDF. Filenames: `inventory-report-YYYY-MM-DD.xlsx` and `inventory-report-YYYY-MM-DD.pdf`. **Empty state**: When there are no batches, manager/admin see an “Add batch” button in the table body; Add-batch modal loads products from `GET /products` and disables Save when no products exist (hint: add products in Manage → Products first).
- **Manager role and dashboard**: Admin creates managers via **Team** page (`POST /users` with role=manager). Manager can **add, list, view, and disable** pharmacists only via Team: list shows only pharmacists; add user (role fixed to pharmacist); **View** opens pharmacist detail page (`/manage/team/:id`) with read-only details and Edit/Disable actions; Edit modal allows name and active toggle (manager cannot change role); Deactivate sets `is_active` to false. Manager has **Duty Roster** (assign pharmacists to dates with morning/evening/full shift) and **Daily Logs** (date-scoped tasks with open/done). Manager dashboard shows: Total Orders, Products, Pharmacists count, Today’s shifts, Today’s tasks. Quick login includes manager@careplus.com (seed adds Manager User with role manager).
- **Referral & points (frontend)**: Checkout (Store and Products explore) includes optional Phone (for customer identification), Referral code, and points redeem. Order create payload sends `customer_phone`, `referral_code`, `points_to_redeem` when provided. Configuration page has a “Referral & points” section (points per currency unit, referral reward, redemption rate, max redeem per order); admin can save via `PUT /referral/config`. Dashboard “Customers” page (`/manage/customers`) lists customers (name, phone, email, referral code, points balance, referred by) with pagination and lookup by phone. **Customer by-phone with membership**: `GET /customers/by-phone?phone=X` returns customer with optional `membership: { id, name }` when the customer has an active CustomerMembership; backend preloads CustomerMembership + Membership in the referral service and handler returns `CustomerWithMembership`. Used by Billing page to show membership name and apply membership discount at order create.
- **Language (Nepali / English)**: For Nepali-speaking users, the app supports English and नेपाली (Nepali). A **language switcher** (EN | नेपाली) is shown in the **top bar** of both the dashboard layout (`Layout.tsx`) and the public website layout (`WebsiteLayout.tsx`). Choice is persisted in `localStorage` (`careplus_locale`) and applied app-wide. `LanguageContext` provides `locale`, `setLocale`, and `t(key, params?)`; translations live in `lib/translations.ts` (flat keys, e.g. `nav_dashboard`, `auth_login`). Public pages (Login, Register, Products catalog, product cards, cart, footer) and dashboard (sidebar labels, header notifications/profile, logout confirm) use `t()` so all user-facing strings switch with the selected language. New pages should use `useLanguage()` and `t(key)` for any user-visible text; add new keys to both `en` and `ne` in `translations.ts`. Interpolation for dynamic values uses `{{name}}` in the string and `t('key', { name: value })`.

---

## Discovered Edge Cases

1. **Bootstrap**: There is no unauthenticated “create first pharmacy” flow. Options: (a) allow one-time `POST /pharmacies` without auth and then register first user with that pharmacy_id, or (b) provide a seed script / migration that creates a default pharmacy and admin user.
2. **Order and stock**: Creating an order decrements product stock. Cancelling an order does not yet restore stock; that should be added when cancellation is implemented.
3. **Order status transitions**: Invalid status changes (e.g. pending → completed) are rejected by the API with a validation error; the UI only offers valid next statuses per current status.
4. **Payment completion**: “Complete” sets status and paid_at. Refunds or partial payments are not yet modeled; the current design supports one payment per order from the UI perspective, but the schema allows multiple payments per order.
5. **Billing**: Barcode not found returns 404; Billing page shows the API error. Duplicate invoice: only one invoice per order; if “Generate bill” is triggered twice for the same order (e.g. after a failed navigation), the second `createFromOrder` returns CONFLICT (“invoice already exists for this order”); the UI shows the error. QR format for products: encode product UUID only; scanner or manual paste decodes and calls `GET /products/:id`.
6. **Product uniqueness**: SKU is unique globally in the schema; the API uses pharmacy scope in practice. If multiple pharmacies are allowed to have the same SKU, the unique constraint should be changed to (pharmacy_id, sku).
7. **Store vs dashboard**: The public store shows products from a selected pharmacy. Orders are created with the logged-in user’s `pharmacy_id` from JWT. If the user’s pharmacy does not match the store’s selected pharmacy, order creation will fail (backend: “product does not belong to this pharmacy”). The store switches to the user’s pharmacy when they log in to avoid this.
8. **Member discount vs promo code**: Both can apply to the same order: membership discount is applied when customer_phone matches a customer with a CustomerMembership; promo code discount is then added. Total discount is capped at sub_total. If no customer_phone is sent, membership discount is not applied.
9. **First-order-only promo code**: PromoCode has optional `first_order_only`. When true, validate checks order count for the authenticated user at this pharmacy; if the user has already placed any order, the code returns an error. Validate requires auth so user_id is available; unauthenticated validate (e.g. query) passes userID=nil and first-order-only codes will fail with “please log in”.
10. **Referral & points**: Customer is per pharmacy; same phone in two pharmacies = two customers. Referral reward is credited only on the referred customer’s **first completed** order. Points redeem is applied at order create (balance deducted and PointsTransaction recorded); if order is later cancelled, points are not auto-reverted (future: revert on cancel). Rounding: earn = floor(amount / currency_unit) * points_per_unit; redeem discount = floor(points / rate_points) * rate_currency, capped by order subtotal and max_redeem_per_order.
11. **Subcategory dropdown (Add Product)**: Subcategories are loaded on demand when a parent category is selected. The frontend calls `GET /categories?parent_id=UUID` when the user picks a parent so the subcategory dropdown is populated from the API; the dropdown shows "Select parent first" when no parent is chosen and "Loading…" while fetching. The "Selected" label shows "Parent › Subcategory" when a subcategory is chosen. If a new category is created from the Add Category modal with a parent matching the current selection, the subcategory list is refetched so the new option appears.

---

## Customer attraction (pharmacy & beauty)

- **Promo code at checkout**: Cart/checkout on explore and store pages include a promo code input. User applies a code; frontend calls `POST /promo-codes/validate` with code and sub_total; discount is shown and passed to `POST /orders` as `promo_code`. Backend re-validates at order creation.
- **Promo code management (pharmacist)**: Pharmacists (and admin/manager) can create and manage discount codes from the dashboard. **Promo codes** (`/promo-codes`, Tag icon) lists all codes for the pharmacy; Add/Edit modal supports code, discount type (percent/fixed), discount value, min order amount, valid from/until, max uses (0 = unlimited), first-order-only, and active toggle. Codes are applied at Billing (POS), Store, and Products explore checkout; order create re-validates and increments used count. API: `GET/POST/PUT /promo-codes` (list, create, update) use JWT pharmacy_id; validate remains `POST /promo-codes/validate`.
- **Rx/OTC and label badges**: Product cards and detail page show a “Prescription” or “OTC” badge from `requires_rx`. Product `labels` (e.g. certified, dermatologist_tested) are shown as small badges on cards (up to 3) and all on detail.
- **Catalog filters**: Public catalog supports `hashtag`, `brand`, `label_key`/`label_value` query params. Frontend filter bar includes inputs for these; “Clear filters” resets them. Hashtag uses JSONB array containment; label uses JSONB key-value containment.
- **Rating on product cards**: Catalog API enriches each product with `rating_avg` and `review_count` from product_reviews. Frontend product cards show star rating and “(N reviews)” when review_count > 0.
- **Recently viewed / You might like**: Recently viewed product IDs are stored in localStorage (max 10). Product detail page adds current product to recent and shows “Recently viewed” (up to 5) and “You might like” (same category, same pharmacy, excluding current, up to 4). Explore page shows “Recently viewed” horizontal strip when non-empty.
- **Pharmacy verified badge**: PharmacyConfig has optional `license_no`, `verified_at`, `established_year`. When `verified_at` is set, the public website header shows a “Verified” badge. Config page (dashboard) includes “Trust & verification” section to set these.
- **First-order-only promo**: PromoCode has `first_order_only`. When set, validate fails if the authenticated user has any prior order at this pharmacy. Cart shows hint “First order? Try a welcome code if you have one.”
- **Promo end date on What’s on**: “What’s on” promo cards display “Offer ends &lt;date&gt;” (or “Starts &lt;date&gt;”) when `end_at` or `start_at` is set.

---

## Performance Optimizations

- Backend: GORM connection pool (MaxIdleConns, MaxOpenConns, ConnMaxLifetime). Zap for structured logging; log level can be tuned per environment.
- Frontend: Vite for fast HMR and builds. No heavy dependencies. Product lists use pagination (limit/offset) so 18+ products load one page at a time; dashboard default 10 per page, store 12 per page.

---

## User Feedback Incorporation

- Initial scope focused on pharmacy management, products, orders, and payments as requested. Auth and role model kept simple (single pharmacy, role string) so it can be extended (e.g. permissions per role) based on feedback.
- README and this document describe bootstrap and first-use flow so that “how do I create the first pharmacy/user?” is documented.

---

## Unit testing (no database)

- **Domain services** are tested with mocks only (no DB, no real JWT). Mocks live in `internal/mocks/outbound`: hand-written stubs for `UserRepository`, `PharmacyRepository`, `ProductRepository`, and `AuthProvider`. Tests set `*Func` fields to control return values.
- **Tests**: `internal/domain/services/*_test.go` cover `AuthService` (Register, Login, GetCurrentUser, conflict/not-found paths), `PharmacyService` (Create, GetByID, List, Update, validation), and `ProductService` (Create, GetByID, List, UpdateStock, Delete, validation/SKU conflict).
- **mockgen**: Optional. `//go:generate` directives in `internal/ports/outbound` allow regenerating mocks with `go generate ./internal/ports/outbound/...` when mockgen is installed. Hand-written mocks are used by default so tests run without network/tools.

---

## Seeder & Quick Login (demo)

- **Backend**: `go run ./cmd/seed` creates one demo pharmacy and four users (same password `password123`): **admin@careplus.com** (Admin), **pharmacist@careplus.com** (Pharmacist), **buyer@careplus.com** (End user / staff), and **test@careplus.com** (Admin, legacy). All belong to the same demo pharmacy.
- **Frontend**: Login page has "Quick login (demo)" buttons for Admin, Pharmacist, and End user (Buyer). Each button logs in with the corresponding seeded account so different roles can be tried without typing credentials.

---

## Analytics sidebar (planned)

- **Plan:** See `docs/ANALYTICS_SIDEBAR_PLAN.md` for the full backend and frontend plan.
- **Purpose:** Dedicated analytics page (or collapsible sidebar) for managers and stakeholders with charts and KPIs.
- **Time ranges:** Today, weekly, monthly, quarterly, yearly, custom date range (query params `from`, `to`, `period`).
- **Charts:** Bar (revenue/orders by period, by category, top products), line (revenue/orders over time), trend (growth vs previous period), heatmap (activity by hour × day), pie (revenue by category, orders by status, payment methods), plus KPI summary cards.
- **Backend:** New `AnalyticsService` and handler; endpoints under `GET /api/v1/analytics/*` (summary, revenue-by-period, orders-by-period, revenue-by-category, top-products, revenue-over-time, orders-over-time, trend, heatmap, orders-by-status, payment-methods); pharmacy-scoped; optional `RequireAdminOrManager()`.
- **Frontend:** Route `/analytics`, date range selector (presets + custom), Recharts for charts, `analyticsApi` in `lib/api.ts`, sidebar entry for admin/manager.

---

## Chat (implemented)

- **Plan:** See `docs/CHAT_FEATURE_PLAN.md` for the full backend and frontend design.
- **Purpose:** Real-time chat between pharmacists (pharmacy staff) and end customers, with file and photo sharing.
- **Transport:** REST API for conversation/message CRUD and history; WebSocket for real-time delivery, typing indicators, and optional read receipts.
- **Participants:** Staff identified by existing JWT; customers by `Customer` (pharmacy + phone), with access via a short-lived **chat token** (e.g. link sent by staff or after phone/OTP).
- **Models:** `Conversation` (one per pharmacy + customer), `ChatMessage` (sender_type: user|customer, body, optional attachment_url/name/type). Attachments use existing `FileStorage` (same types/size as current upload).
- **API:** `GET/POST /chat/conversations`, `GET /chat/conversations/:id/messages`, `POST /chat/conversations/:id/messages`; upload via existing `POST /upload` or dedicated chat upload.
- **WebSocket:** Single endpoint (e.g. `/api/v1/chat/ws?token=...`); JSON protocol for `send_message`, `new_message`, `typing`, optional `read`; in-memory hub routes by user/customer.
- **Frontend:** Dashboard chat page (conversation list + message thread + attach/send); store/website chat panel for customers (token in URL or session). `chatApi` in `lib/api.ts` and a small WebSocket helper for real-time updates.
- **Pharmacist / admin / manager:** Can see **all customer chats** for the pharmacy: sidebar "Chat" is shown to roles `admin`, `manager`, `pharmacist`; `GET /chat/conversations` returns all pharmacy conversations when not role `staff`. Role **staff** (end-user/buyer) sees only their own conversation via `GET /chat/me` and a single-thread view.
- **Chat message edit and delete:** Users and customers can **edit** their own messages only within a configurable time window (default 10 minutes), and **delete** their own messages anytime. **Delete conversation** removes the conversation and all its messages for the current user (customer or staff). Backend: `PATCH /chat/conversations/:id/messages/:messageId` (body), `DELETE /chat/conversations/:id/messages/:messageId`, `DELETE /chat/conversations/:id`. Edit is allowed only if the message was sent within the last N minutes; N is set by admin in pharmacy config. `ChatMessage` has `updated_at`; when `updated_at` > `created_at` the UI shows “(edited)”.
- **Chat edit window (admin):** `PharmacyConfig` has **chat_edit_window_minutes** (default 10). Admins configure it on the Config page (Pharmacy configuration → Chat section). Set to 0 to disable editing. `GET /chat/settings` returns `{ chat_edit_window_minutes }` for the current chat context so the frontend can show/hide the Edit action per message.

---

## Possible Next Steps

- Pagination and filters for orders (products pagination done; orders could follow same pattern).
- Order cancellation with stock restoration.
- Payment refunds or partial payments.
- Prescription/repeat script tracking if required.
- Audit log for sensitive actions (e.g. payment complete, order status change).
- **Analytics:** Implement analytics sidebar per `docs/ANALYTICS_SIDEBAR_PLAN.md`.
- **Chat:** Implemented per `docs/CHAT_FEATURE_PLAN.md` (REST + WebSocket, file/photo sharing). Dashboard: Chat page; customer: `/customer-chat?token=...` with token from `POST /chat/customer-token`.

---

## Activity logs

- **Purpose**: Maintain a feed of API activity per pharmacy so staff can see who did what and when.
- **Backend**: `ActivityLog` model (id, pharmacy_id, user_id, action, entity_type, entity_id, details, ip_address, created_at). Action is stored as `METHOD path` (e.g. `GET /orders`, `POST /products`). `ActivityLogRepository` (Create, ListByPharmacy with limit/offset), `ActivityLogService` (Create, ListByPharmacy), `ActivityHandler` (GET `/api/v1/activity`). Activity is recorded by middleware: after Auth, every authenticated request is logged (method + path, user, pharmacy, IP). Table `activity_logs` is created via AutoMigrate.
- **Frontend**: "Activity" link in the sidebar (lucide-react Activity icon), route `/activity`, `ActivityPage` that fetches `GET /api/v1/activity` and displays a table of time, user, action, IP. `activityApi.list()` in `lib/api.ts` with optional limit/offset.
- **Edge case**: Logging is best-effort; if Create fails we log at debug and do not fail the request. List is scoped to the current pharmacy from JWT.
- Seed script or “setup wizard” for first pharmacy and admin user.
