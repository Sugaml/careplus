# CarePlus Pharmacy – Design Decisions & Notes

This document captures design decisions, edge cases, and implementation notes for the CarePlus Pharmacy application (aligned with the project rule to maintain such a document as implementation progresses).

---

## Design Decisions

### Architecture

- **Backend**: Ports & adapters (hexagonal) style. Domain lives in `internal/domain` (models + services). Ports: `inbound` (service interfaces), `outbound` (repositories, auth provider). Adapters: HTTP handlers, GORM persistence, JWT auth.
- **Single pharmacy per user**: Users have a `pharmacy_id`; JWT carries `user_id`, `pharmacy_id`, and `role`. All product/order/payment operations are implicitly scoped to the user’s pharmacy.
- **No separate “account” entity**: Unlike the parent a-OK Enterprise app, CarePlus uses Pharmacy as the top-level tenant; users belong to one pharmacy with roles (admin, pharmacist, staff).

### Data model

- **Pharmacy**: id, name, license_no, address, phone, email, is_active.
- **User**: id, pharmacy_id, email, password_hash, name, role, is_active. **Roles**: admin, manager, pharmacist, staff.
- **Product**: id, pharmacy_id, name, description, sku, category (string, denormalized name for filter; synced from Category when category_id set), **category_id** (optional FK to Category — product type = category + subcategory; when set, category_detail and parent are known), unit_price, currency, stock_quantity, unit, requires_rx, is_active, expiry_date, manufacturing_date, brand, barcode, storage_conditions, dosage_form, pack_size, generic_name, **hashtags** (JSONB), **labels** (JSONB). API returns **category_detail** (id, name, parent: { id, name }) when category_id is set. Batch-level expiry remains on InventoryBatch (FEFO).
- **Order**: id, pharmacy_id, order_number, customer_*, **customer_id** (nullable FK to Customer), **referral_code_used**, **points_redeemed**, status, sub_total, total_amount, currency, notes, created_by.
- **OrderItem**: id, order_id, product_id, quantity, unit_price, total_price.
- **Customer**: id, pharmacy_id, name, phone, email, **referral_code** (unique per pharmacy, 8-char), **points_balance**, **referred_by_id** (nullable FK to Customer). Identified by (pharmacy_id, phone); created or linked on first order for referral and points.
- **PointsTransaction**: id, customer_id, amount (+ earn / − redeem), type (earn_purchase | earn_referral | redeem), order_id, referral_customer_id (for earn_referral). Ledger for audit.
- **ReferralPointsConfig**: id, pharmacy_id, points_per_currency_unit, currency_unit_for_points, referral_reward_points, redemption_rate_points, redemption_rate_currency, max_redeem_points_per_order (0 = no cap). Per-pharmacy rules; if missing, referral/points are disabled.
- **Payment**: id, order_id, pharmacy_id, amount, currency, method, status, reference, paid_at, created_by.
- **Invoice**: id, pharmacy_id, order_id, invoice_number (unique per pharmacy), status (draft, issued), issued_at, created_by. One invoice per order; created from an order via `POST /orders/:orderId/invoices`. Draft can be issued via `POST /invoices/:id/issue`.
- **PharmacyConfig**: id, pharmacy_id (unique), display_name, location, logo_url, banner_url, tagline, contact_phone, contact_email, primary_color, license_no, verified_at, established_year. One row per pharmacy for website branding and media. When `verified_at` is set, the public store shows a "Verified pharmacy" badge.
- **Category**: id, pharmacy_id, **parent_id** (nullable; nil = top-level, set = subcategory), name, description, sort_order. **GET /categories?parent_id=** returns children when set. Products link via category_id; API returns category_detail with parent.
- **ProductUnit**: id, pharmacy_id, name, description, sort_order. Per-pharmacy units of measure (e.g. tablet, bottle, box, ml). Maintained by the pharmacist like Category; product form can use product-units list for the unit dropdown; products keep `unit` as a string.
- **Membership**: id, pharmacy_id, name, description, discount_percent (0–100), is_active, sort_order. Per-pharmacy loyalty tiers — names and details are dynamic (defined via API/UI, no fixed tier list). **CustomerMembership**: id, customer_id, membership_id. Links a customer to a tier; when an order is placed with a customer_phone that matches a customer with a membership, the membership discount is applied to the order (before promo code). Admin can assign customers to tiers via customer_memberships.
- **Promo**: id, pharmacy_id, type (offer | announcement | event), title, description, image_url, link_url, start_at, end_at, sort_order, is_active. Per-pharmacy promotional content shown on the public store (ads-style banners). Used for offers, announcements, and events to inform users.
- **DutyRoster**: id, pharmacy_id, user_id (pharmacist), date, shift_type (morning | evening | full), notes. Manager/admin assigns pharmacists to shifts by date.
- **DailyLog**: id, pharmacy_id, date, title, description, status (open | done), created_by. Manager/admin creates daily tasks (e.g. opening checklist, closing tasks); status can be toggled.

Orders and payments use string status enums (e.g. pending, confirmed, completed) for simplicity; value objects can be introduced later if needed.

- **Order status flow**: Order statuses are `pending` → `confirmed` → `processing` → `ready` → `completed`, with `cancelled` allowed from pending/confirmed/processing/ready. Completed and cancelled are terminal. The backend enforces valid transitions in `UpdateStatus`; invalid transitions return `VALIDATION_ERROR`.
- **Order accept**: `POST /api/v1/orders/:orderId/accept` accepts a pending order (sets status to `confirmed`). Only pending orders can be accepted; otherwise returns validation error. Both Accept and `PATCH /orders/:orderId/status` return the updated order so the UI can refresh without refetching the list.
- **Invoices**: Create from order (`POST /orders/:orderId/invoices`); list (`GET /invoices`); get full view (`GET /invoices/:id` returns invoice + order + items + payments); issue draft (`POST /invoices/:id/issue`). Creating an invoice for an order that already has one returns `CONFLICT`.

### API design

- REST over JSON. Auth: Bearer token from login/refresh. Protected routes read `pharmacy_id` from middleware (JWT) so handlers don’t take it from body/path for write operations.
- **Public store API**: Products and pharmacies are visible without login. Routes under `/api/v1/public/`: `GET /public/pharmacies`, `GET /public/pharmacies/:pharmacyId`, `GET /public/pharmacies/:pharmacyId/config`, `GET /public/pharmacies/:pharmacyId/products`, `GET /public/pharmacies/:pharmacyId/categories`, `GET /public/pharmacies/:pharmacyId/promos` (offers, announcements, events; optional `?type=offer,announcement,event`), `GET /public/products/:id`. Add-to-cart and place-order require login (protected `/orders` and cart state in frontend).
- **Product catalog API**: `GET /public/pharmacies/:pharmacyId/products` supports catalog params: `q` (search on name, description, SKU, brand, generic_name; ILIKE), `sort` (name|price_asc|price_desc|newest), `category`, `in_stock`, `hashtag`, `brand`, `label_key`, `label_value`, `limit`, `offset`. When `q`, `sort`, or any of hashtag/brand/label is present, the backend uses catalog listing (active products only). Catalog response items include optional `rating_avg` and `review_count` (aggregated from product reviews). Repository: `ListByPharmacyCatalog(..., filters *CatalogFilters)`; service: `ListCatalog(..., filters)`.
- **Product QR and barcode**: Products have an optional `barcode` field (indexed). `GET /api/v1/products/by-barcode/:barcode` (auth required) returns the product for the current pharmacy with that barcode; 404 if not found. Used for barcode lookup and scanning. QR codes encode the product UUID so scanners or internal tools can resolve the product via `GET /products/:id`. Frontend: Products page has a “Lookup by barcode” input, an “Actions” column with “QR/Barcode” per row, and a modal that shows QR code (qrcode.react) and barcode image (react-barcode) when set.
- **Pharmacy config API**: Protected `GET /config` (get-or-create for current pharmacy), `PUT /config` (upsert). Public `GET /public/pharmacies/:pharmacyId/config` for website banner, logo, name, location, etc.
- **Dashboard stats API**: Protected `GET /api/v1/dashboard/stats` returns counts for the current pharmacy: `orders_count`, `products_count`, `pharmacists_count`, `today_roster_count`, `today_dailies_count`. For non-manager roles, manager-only fields are 0. Used by the dashboard page so one request loads all stats; products count uses `ListPaginated(limit=1)` for total only.
- **Admin-only routes**: JWT carries `role` (admin, manager, pharmacist, staff). `RequireAdmin()` middleware returns 403 if `role != "admin"`. Only admins can: `POST /api/v1/pharmacies`, `PUT /api/v1/pharmacies/:id`, `GET /api/v1/config`, `PUT /api/v1/config`, `POST /api/v1/notifications`, **Promos** (`GET /promos`, `POST /promos`, `GET /promos/:id`, `PUT /promos/:id`, `DELETE /promos/:id`), and `PUT /referral/config`. Staff and pharmacist can list pharmacies, get pharmacy by ID, and use products/orders/payments.
- **Admin or Manager routes**: `RequireAdminOrManager()` middleware allows admin or manager. **Users**: `GET /users` (admin: all pharmacy users; manager: only pharmacists), `POST /users` (admin: role manager/pharmacist/staff; manager: role pharmacist only), `GET /users/:id`, `PUT /users/:id`, `PATCH /users/:id/deactivate`. **Duty roster**: `GET /duty-roster?from=&to=`, `POST /duty-roster`, `GET /duty-roster/:id`, `PUT /duty-roster/:id`, `DELETE /duty-roster/:id`. **Daily logs**: `GET /daily-logs?date=`, `POST /daily-logs`, `GET /daily-logs/:id`, `PUT /daily-logs/:id`, `DELETE /daily-logs/:id`. **Inventory (write)**: Only admin or manager can add/update/delete inventory batches: `POST /products/:id/batches`, `PATCH /inventory/batches/:batchId`, `DELETE /inventory/batches/:batchId`. List and get remain on the general auth group so pharmacist, manager, and admin can view inventory (`GET /inventory/batches`, `GET /inventory/expiring`, `GET /inventory/batches/:batchId`). Manager cannot create admins or other managers; manager can only manage pharmacists (list/create/get/update/deactivate). Duty roster assigns pharmacists to dates with shift type (morning/evening/full). Daily logs are date-scoped tasks with open/done status.
- Error responses: `{ code, message }` with HTTP status reflecting the error type (4xx/5xx). For validation errors (400), the API may return `{ code, message, fields }` where `fields` is a map of field names (snake_case, e.g. `email`, `pharmacy_id`, `name`, `sku`) to error messages so the UI can show inline field-level errors.
- **Validation (required/optional)**: Request DTOs use `binding` tags (go-playground/validator) for required fields and rules (e.g. `required`, `email`, `min=6`, `gte=0`, `lte=100`). Handlers use `response.BindValidationError()` so validation failures return structured `fields` (snake_case keys) for the UI. Required vs optional is aligned: auth (email, password required; name, role optional); product (name, sku, unit_price required; description, category, dates, etc. optional); pharmacy (name, license_no required); category (name required); order (items required); membership (name required, discount_percent 0–100). Frontend: forms (Login, Register, Add Product) show required (*) and optional labels, run client-side validation matching API rules, and display API field errors inline via `ApiError.fields`.
- **Categories API**: Protected `GET /api/v1/categories` (list all by pharmacy) or `GET /api/v1/categories?parent_id=UUID` (list children of parent; omit for top-level). `POST`/`PUT` accept optional **parent_id** for subcategories. Used by the dashboard “Categories” page (parent picker in Add/Edit) and by the product form (parent → subcategory dropdowns for product type).
- **Product Units API**: Protected `GET /api/v1/product-units` (list by pharmacy), `POST /api/v1/product-units`, `GET /api/v1/product-units/:id`, `PUT /api/v1/product-units/:id`, `DELETE /api/v1/product-units/:id`. Per-pharmacy units of measure (e.g. tablet, bottle, box, ml), maintained by the pharmacist like categories. Used by the product form unit dropdown; products keep `unit` as a string that can match a product unit name.
- **Memberships API**: Protected `GET /api/v1/memberships` (list by pharmacy), `POST /api/v1/memberships`, `GET /api/v1/memberships/:id`, `PUT /api/v1/memberships/:id`, `DELETE /api/v1/memberships/:id`. Per-pharmacy membership tiers (name, description, discount_percent, is_active, sort_order). Validation: name required; discount_percent 0–100. Used by the dashboard “Memberships” page.
- **Promos API (offers, announcements, events)**: Public `GET /api/v1/public/pharmacies/:pharmacyId/promos` returns active promos for that pharmacy (optional `?type=offer,announcement,event`). Only promos with `is_active=true` and current time within `start_at`/`end_at` are returned. Admin-only: `GET /promos`, `POST /promos`, `GET /promos/:id`, `PUT /promos/:id`, `DELETE /promos/:id`. Body: type (offer|announcement|event), title (required), description, image_url, link_url, start_at, end_at (RFC3339), sort_order, is_active. Frontend: public products page shows a “What’s on” section (horizontal scroll of promo cards); dashboard “Offers & events” page (`/promos`) for admin CRUD.
- **Referral & points API**: Public `GET /api/v1/public/pharmacies/:pharmacyId/referral/validate?code=XXX` validates a referral code (returns valid, name). Protected: `GET /referral/config` (get-or-create with defaults), admin `PUT /referral/config` (upsert rules). `GET /customers` (paginated), `GET /customers/by-phone?phone=XXX`, `GET /customers/:customerId/points` (points history), `GET /referral/redeem-preview?customer_id=...&points_to_redeem=...&sub_total=...` (for checkout UI). Order create accepts optional `referral_code` and `points_to_redeem`; backend get-or-creates customer by phone, applies referral and points discount, and on order completion credits earn_purchase and (if first completed order) earn_referral; redeem is applied at order create and recorded in PointsTransaction.
- **Product reviews, like, comment and feedback**: Any authenticated user can leave a review (rating 1–5, optional title, body) per product; one review per user per product. Public: `GET /public/products/:productId/reviews` lists reviews (no auth). Auth: `POST /products/:id/reviews` (create), `GET /reviews/:id`, `PUT /reviews/:id`, `DELETE /reviews/:id`, `POST /reviews/:id/like`, `DELETE /reviews/:id/like`, `GET /reviews/:id/comments`, `POST /reviews/:id/comments`, `DELETE /comments/:id`. Reviews include like_count, user_liked (when auth), comment_count. Frontend: product detail page `/products/:id` shows product info, reviews list, “Write a review” form (auth), like button, and expandable comments with add-comment (auth).
- **File upload (photos/files)**: `POST /api/v1/upload` (auth required). Multipart form with field `file` or `photo`. Max 10 MiB. Allowed types: images (jpeg, png, gif, webp, svg), PDF, Word. Response: `{ "url": "...", "path": "...", "filename": "..." }`. Storage backend is chosen by **FS_TYPE**: `local` (default) or `s3`.
  - **FS_TYPE=local**: Files saved under `FS_LOCAL_BASE_DIR` (default `./data/images`). Served at `FS_LOCAL_BASE_URL` (default `/data/images`). Set in `.env`: `FS_TYPE=local`, `FS_LOCAL_BASE_DIR=./data/images`, `FS_LOCAL_BASE_URL=/data/images`. Product images are stored under `data/images/photos/products/<productId>/<year>/<month>/<uuid>.<ext>`. Backend serves static files at `LocalBaseURL` from `LocalBaseDir`; returned `url` is a path (e.g. `/data/images/photos/...`) usable when frontend and API share origin or when the frontend proxies image paths to the API.
  - **FS_TYPE=s3**: Files stored in the configured S3 (or MinIO) bucket. Env: `S3_BUCKET`, `S3_REGION`, `S3_ACCESS_KEY`, `S3_SECRET_KEY`; optional `S3_ENDPOINT` for MinIO. Returned `url` is path-style (`/bucket/key`); frontend or CDN may need to prepend base URL or use presigned URLs for public read.
  - **Frontend image display**: Product image URLs from the API are relative (e.g. `/data/images/photos/...` or legacy `/uploads/...`). Vite dev server proxies `/data/images` and `/uploads` to the backend so images load. All product image `<img src>` use `resolveImageUrl(url)` from `lib/api.ts`; when `VITE_API_ORIGIN` is set (e.g. in production with API on another host), relative URLs are resolved against it so images display correctly.

### Frontend

- React 18, Vite, TypeScript, Tailwind. Single SPA with React Router. Auth stored in context + localStorage (access token); optional refresh token support can be added.
- **Public website (explore) / Product catalog**: Route `/products` is the main unauthenticated product catalog: header (logo, Products, Register, Login), footer (copyright, links), and product grid. Visiting the site root `/` when not logged in redirects to `/products`. The catalog includes: pharmacy selector (if multiple), **search bar** (debounced; searches name, description, SKU, brand, generic name), **category dropdown** (from `GET /public/pharmacies/:pharmacyId/categories`), **sort** (Name A–Z, Price low–high, Price high–low, Newest first), **In stock only** toggle, and **Clear filters**. Pagination and product cards unchanged; “Add to cart” disabled for out-of-stock; “Add to cart” and “Place order” require login (`returnTo=/products`). Cart is client-side (CartContext); orders use protected `orderApi.create`. When logged in, header shows Dashboard, Cart, user email, Logout. `/login` and `/register` use the same `WebsiteLayout`. Catch-all route `*` sends guests to `/products`. Staff product management (table) lives at `/manage/products` (protected).
- API client: single `api()` helper that adds base path and Authorization header; typed API functions and shared types in `lib/api.ts`. Public store uses `publicStoreApi` (same base, no token required).
- **Categories**: Sidebar includes “Categories” (`/manage/categories`). Table lists name, description, sort order; Add/Edit modal (name, description, sort order); delete with confirmation. Product form category field: if categories exist, a dropdown lists them plus “Other (type below)” for custom text; otherwise a plain text input.
- **Memberships (dynamic tiers)**: Tiers are fully dynamic: backend stores per-pharmacy memberships (name, description, discount_percent, is_active, sort_order) with no fixed tier names. API: `GET/POST/PUT/DELETE /api/v1/memberships` (list by pharmacy from JWT). UI: “Memberships” (`/manage/memberships`) loads tiers from the API, table lists name, description, discount %, active, sort order; Add/Edit modal creates or updates tiers. Used to define loyalty tiers (any names the pharmacy chooses) with optional member discount; assign tiers to customers and apply discount at checkout.
- **Add Product**: Products page (`/manage/products`) has a 5-step “Add Product” modal: (1) **Details** — name, SKU (required), description, **Category / Product type** (optional: parent category dropdown → subcategory dropdown; selecting a category/subcategory sets category_id so the product knows its parent); (2) **Images** — add at least one image; (3) **Pricing & Stock** — unit price, currency, stock quantity, unit; (4) **Dates & Properties** — manufacturing/expiry dates, brand, barcode, dosage form, pack size, generic name, storage, requires prescription, active; (5) **Review & Submit** — full review summary, then “Add Product”. API returns **category_detail** (with parent) so the products table and product detail page show “Parent > Subcategory” or category name.
- **Product images**: Products support multiple images with a primary image. Backend: `ProductImage` model (product_id, url, is_primary, sort_order); `POST /products/:id/images` (multipart file + optional `is_primary`), `PATCH /products/:id/images/:imageId/primary`, `DELETE /products/:id/images/:imageId`. Images are stored via existing `FileStorage` (local or S3). Product Get/List preload `Images`. In Add Product step 4, after the user clicks “Create Product”, the image upload UI is shown; the user must add at least one image before “Done” is enabled. Product list table and store/explore product cards show the primary image; cart and order flows show product thumbnails. Order repository preloads `Product.Images` when loading order items.
- **Product QR and barcode (UI)**: On the Products page (`/manage/products`): (1) “Lookup by barcode” input in the header—enter a barcode and click Lookup (or press Enter) to fetch the product and open the QR/Barcode modal. (2) Each row has an “Actions” column with a “QR/Barcode” button that opens a modal showing: QR code (encoding product ID via `qrcode.react`) and barcode image (via `react-barcode`) when the product has a barcode; otherwise “No barcode set”. QR codes can be printed or scanned to resolve the product; barcode is for standard barcode scanners.
- **Product list pagination (18+ products)**: To maintain many products without loading all at once, list endpoints support optional `limit` and `offset` query params. When `limit > 0`, the API returns `{ items: Product[], total: number }`; when omitted, it returns the full array (backward compatible). **API**: `GET /products?limit=10&offset=0` (protected) and `GET /public/pharmacies/:pharmacyId/products?limit=12&offset=0` (plus optional `q`, `sort`, `category`, `in_stock` for catalog) return paginated responses. Protected `GET /products` also accepts optional `q` (search on name, SKU, brand, generic_name); when `q` is present the handler uses `ListCatalog` with default sort and limit (e.g. 20) for Billing/dashboard search. **Repository**: `ListByPharmacyPaginated(...)` and `ListByPharmacyCatalog(..., searchQ, sort, limit, offset)` for catalog. **UI**: Dashboard Products page (`/manage/products`) uses `productApi.listPaginated()` with default 10 per page; Billing page uses `productApi.listPaginated({ q, limit: 20 })` for product search. Public Product catalog (`/products`) uses `publicStoreApi.listProductsPaginated()` with 12 per page, search/sort/category/in-stock filters. Both pages show “Page X of Y (N total)”.
- **Notifications**: Per-user notifications (title, message, type). API: GET/POST notifications, count unread, mark read, mark all read. Admin POST to create. Seed creates demo notifications for admin user. Frontend: Bell dropdown with unread count; /notifications page with mark-as-read.
- **Invoices**: Sidebar includes “Invoices” (`/invoices`). List shows invoice number, status (draft/issued), date; “View” opens invoice detail (`/invoices/:id`). Detail page shows bill-to, line items (from order), totals, and payments; “Issue invoice” button for drafts. Orders page has “Invoice” button to create an invoice from an order; on success navigates to the new invoice detail. Creating an invoice for an order that already has one shows the API error (e.g. “invoice already exists for this order”).
- **Billing (POS)**: Sidebar includes “Billing” (`/billing`, Receipt icon). POS-style page: add items via **scan barcode** (`GET /products/by-barcode/:barcode`), **product ID** (UUID in search → `GET /products/:id`), or **name/SKU search** (`GET /products?q=...&limit=20`). Cart holds line items (product_id, quantity, unit_price); optional **customer** (phone lookup via `GET /customers/by-phone?phone=X` returns customer with optional **membership** `{ id, name }` and points balance). Optional **promo/voucher code** (validate via `POST /promo-codes/validate`), **manual discount**, and **redeem points** (preview via `GET /referral/redeem-preview`). “Generate bill” creates order → invoice → issues invoice; then optional “Record payment” modal (amount, method) creates and completes a payment. Protected `GET /products` accepts optional `q` for dashboard product search (uses ListCatalog when `q` present). QR scan: encode product UUID; on scan decode and call `GET /products/:id`.
- **Statements / Transactions**: Sidebar includes “Statements” (`/statements`, ListOrdered icon). Single page with tabs: **Orders**, **Payments**, **Invoices**. Data from existing `orderApi.list()`, `paymentApi.list()`, `invoiceApi.list()`. Optional **date range filter** (from / to) applied on the frontend. Tables show order number, date, customer, status, total (orders); date, order ref, amount, method, status (payments); invoice number, date, status with link to detail (invoices). “Print statement” opens a print window with aggregated summary (order count/total, payment count/total) and tables for the selected date range (frontend-only aggregation).
- **Light/dark theme**: A `ThemeContext` provides `theme` ('light' | 'dark'), `setTheme`, and `toggleTheme`. Preference is persisted in `localStorage` (`careplus-theme`); initial value falls back to `prefers-color-scheme` when no stored value exists. The `dark` class is applied to `<html>` for dark mode so Tailwind's `dark:` variants and CSS variables (e.g. `--theme-bg`, `--theme-text`) switch smoothly. Semantic tokens in `index.css` and Tailwind (`theme.bg`, `theme.text`, `theme-surface`, `theme-muted`, etc.) give consistent, user-friendly colors and backgrounds in both modes. Theme toggle (sun/moon icon) is available in the dashboard header and in the public website header. Transitions (0.2s ease) on body and theme-aware elements avoid jarring switches.
- **Terms and Conditions / Privacy Policy (Nepal government)**: Registration requires the user to agree to Terms and Conditions and Privacy Policy. Content is aligned with the Government of Nepal **Electronic Transaction Act, 2063 (2006)** and **Privacy Act, 2075 (2018)**. Routes: `/terms`, `/privacy`. Register page includes a required “I agree” checkbox linking to both documents; submit is blocked until checked. Footer (WebsiteLayout) links to Terms and Privacy. Translations for titles and agree text exist in English and Nepali.
- **Branding consistency**: All pages use the same brand: display name, logo, and primary color from pharmacy config. A `BrandContext` fetches config when the user is logged in (`GET /config`) or, for public pages, from the first/selected pharmacy (`GET /public/pharmacies/:id/config`). CSS variables `--brand-primary` and `--brand-secondary` are set on `document.documentElement` so Tailwind’s `careplus-primary` / `careplus-secondary` reflect the configured color. Dashboard layout (sidebar) and website layout (header/footer) show logo (or Pill icon fallback) and display name; Configuration page updates apply immediately via `refreshBrand()`.
- **Dashboard header**: Top-right of the dashboard layout shows a notification bell (dropdown with “No new notifications” placeholder) and a profile avatar (initials from name/email). Avatar dropdown shows user name/email, “Profile settings” (links to `/profile`), and “Log out”. Click-outside closes both dropdowns.
- **Responsive sidebar**: On viewports below the `md` breakpoint, the dashboard sidebar is hidden by default and can be opened/closed. A hamburger (Menu) button in the header opens the sidebar; a close (X) button in the sidebar header and a semi-transparent backdrop (click to close) close it. Clicking any nav link or logout in the sidebar also closes it on mobile. On `md` and up, the sidebar is always visible in flow; the hamburger and backdrop are hidden.
- **Profile settings**: Route `/profile` (protected). Page shows email (read-only), role, and editable display name. `PATCH /api/v1/auth/me` with `{ name }` updates the current user’s name; AuthContext exposes `refreshUser()` so the header avatar and sidebar reflect the new name after save.
- **Loader component**: Reusable Care+ loader (`Loader.tsx`) with variants: `fullPage` (auth check, full viewport with “Care+” branding), `page` (main content area, centered spinner + message), `inline` (tables/cards, compact), `small` (dropdowns, buttons). Uses Care+ teal (`careplus-primary`) spinner, optional message, and `role="status"` / `aria-label` for accessibility. Used on auth route, Layout notifications dropdown, Dashboard, Products, Orders, Invoices, Invoice detail, Payments, Activity, Categories, Config, Notifications, Products explore, Register (pharmacy list), and Store pages.
- **Change password**: Same profile page includes a “Change password” section. User must provide current password, new password (min 6 chars), and confirmation. `PATCH /api/v1/auth/me/password` with `{ current_password, new_password }` (auth required) validates current password, hashes new one, and updates the user; returns 401 if current password is wrong. Frontend clears the form and shows success on success; validation errors (e.g. mismatch, too short) are shown inline.
- **Confirmations**: Update, delete, approve, and logout actions use a shared `ConfirmDialog` component so each has its own confirmation. Logout is confirmed in both dashboard Layout and public WebsiteLayout. Category delete and category update (when editing) use ConfirmDialog. Order accept (approve) and order status change (including cancel) are confirmed. Invoice issue is confirmed. Config save, profile save, and password change are confirmed. Variants: default (primary button), danger (red for delete/cancel), warning (amber) available.
- **Refresh**: Data-loading pages expose a refresh icon (RefreshCw) next to the page title so users can reload the list or config without leaving the page. Pages with refresh: Dashboard, Products, Categories, Orders, Invoices, Invoice detail, Payments, Notifications, Activity, Config, Pharmacy, and the public Products explore page.
- **Role-based sidebar**: Sidebar menu items are filtered by user role via `getVisibleNavEntries(role)` in `Layout.tsx`. Each nav entry can be a link or a group (e.g. Product Management with Products, Categories, Units, Catalog). Optional `roles` array: if absent, the entry is shown to all roles. **admin**: full access (Dashboard, Product Management, **Team**, **Duty Roster**, **Daily Logs**, Memberships, Customers, **Inventory**, Orders, **Billing**, Invoices, Payments, **Statements**, Promos, Notifications, Activity, Pharmacy, Configuration). **manager**: same as admin except no Promos, Activity, Pharmacy, Config. **pharmacist**: same product/membership/customers as manager plus **Inventory** (view only); no Team, Duty Roster, Daily Logs. **staff**: only Dashboard, Orders, Billing, Invoices, Payments, Statements, Notifications. Backend enforces access; sidebar only hides links the role is not intended to use.
- **Inventory (sidebar and list)**: **Inventory** appears in the sidebar for pharmacist, manager, and admin (`/inventory`, Boxes icon). All three roles can view the inventory list (batches by pharmacy with product name, batch number, quantity, expiry date). **Manager and admin** can add batches (modal: select product, batch number, quantity, expiry date), edit batch quantity/expiry, and delete batches; these write operations are restricted to admin or manager in the backend so that “inventory changes can be approved by the manager.” Pharmacist sees the list and a note that changes require manager approval; Add/Edit/Delete actions are hidden for pharmacist. Backend: `GET /inventory/batches` returns batches with Product preloaded; write routes (`POST /products/:id/batches`, `PATCH /inventory/batches/:batchId`, `DELETE /inventory/batches/:batchId`) are under `RequireAdminOrManager()`.
- **Inventory report export**: Inventory page has an **Export report** dropdown with **Export to Excel** and **Export to PDF**. **Excel** export produces a single `.xlsx` file with three sheets: **All Batches** (product, batch number, quantity, expiry date, created at), **Expiring Soon** (batches expiring within 30 days, same columns), and **By Product** (product name, total quantity, batch count). **PDF** export produces a single `.pdf` with the same three sections (title, generated date, then All Batches, Expiring Soon, By Product tables). Exports use current list data plus `GET /inventory/expiring?days=30` for the expiring-soon dataset. Dependencies: `xlsx` (SheetJS) for Excel, `jspdf` and `jspdf-autotable` for PDF. Filenames: `inventory-report-YYYY-MM-DD.xlsx` and `inventory-report-YYYY-MM-DD.pdf`.
- **Manager role and dashboard**: Admin creates managers via **Team** page (`POST /users` with role=manager). Manager can **add, list, view, and disable** pharmacists only via Team: list shows only pharmacists; add user (role fixed to pharmacist); **View** opens pharmacist detail page (`/manage/team/:id`) with read-only details and Edit/Disable actions; Edit modal allows name and active toggle (manager cannot change role); Deactivate sets `is_active` to false. Manager has **Duty Roster** (assign pharmacists to dates with morning/evening/full shift) and **Daily Logs** (date-scoped tasks with open/done). Manager dashboard shows: Total Orders, Products, Pharmacists count, Today’s shifts, Today’s tasks. Quick login includes manager@careplus.com (seed adds Manager User with role manager).
- **Referral & points (frontend)**: Checkout (Store and Products explore) includes optional Phone (for customer identification), Referral code, and points redeem. Order create payload sends `customer_phone`, `referral_code`, `points_to_redeem` when provided. Configuration page has a “Referral & points” section (points per currency unit, referral reward, redemption rate, max redeem per order); admin can save via `PUT /referral/config`. Dashboard “Customers” page (`/manage/customers`) lists customers (name, phone, email, referral code, points balance, referred by) with pagination and lookup by phone. **Customer by-phone with membership**: `GET /customers/by-phone?phone=X` returns customer with optional `membership: { id, name }` when the customer has an active CustomerMembership; backend preloads CustomerMembership + Membership in the referral service and handler returns `CustomerWithMembership`. Used by Billing page to show membership name and apply membership discount at order create.
- **Language (Nepali / English)**: For Nepali-speaking users, the app supports English and नेपाली (Nepali). A **language switcher** (EN | नेपाली) is shown in the **top bar** of both the dashboard layout (`Layout.tsx`) and the public website layout (`WebsiteLayout.tsx`). Choice is persisted in `localStorage` (`careplus_locale`) and applied app-wide. `LanguageContext` provides `locale`, `setLocale`, and `t(key, params?)`; translations live in `lib/translations.ts` (flat keys, e.g. `nav_dashboard`, `auth_login`). Public pages (Login, Register, Products catalog, product cards, cart, footer) and dashboard (sidebar labels, header notifications/profile, logout confirm) use `t()` so all user-facing strings switch with the selected language. New pages should use `useLanguage()` and `t(key)` for any user-visible text; add new keys to both `en` and `ne` in `translations.ts`. Interpolation for dynamic values uses `{{name}}` in the string and `t('key', { name: value })`.

---

## Discovered Edge Cases

1. **Bootstrap**: There is no unauthenticated “create first pharmacy” flow. Options: (a) allow one-time `POST /pharmacies` without auth and then register first user with that pharmacy_id, or (b) provide a seed script / migration that creates a default pharmacy and admin user.
2. **Order and stock**: Creating an order decrements product stock. Cancelling an order does not yet restore stock; that should be added when cancellation is implemented.
3. **Order status transitions**: Invalid status changes (e.g. pending → completed) are rejected by the API with a validation error; the UI only offers valid next statuses per current status.
4. **Payment completion**: “Complete” sets status and paid_at. Refunds or partial payments are not yet modeled; the current design supports one payment per order from the UI perspective, but the schema allows multiple payments per order.
5. **Billing**: Barcode not found returns 404; Billing page shows the API error. Duplicate invoice: only one invoice per order; if “Generate bill” is triggered twice for the same order (e.g. after a failed navigation), the second `createFromOrder` returns CONFLICT (“invoice already exists for this order”); the UI shows the error. QR format for products: encode product UUID only; scanner or manual paste decodes and calls `GET /products/:id`.
6. **Product uniqueness**: SKU is unique globally in the schema; the API uses pharmacy scope in practice. If multiple pharmacies are allowed to have the same SKU, the unique constraint should be changed to (pharmacy_id, sku).
7. **Store vs dashboard**: The public store shows products from a selected pharmacy. Orders are created with the logged-in user’s `pharmacy_id` from JWT. If the user’s pharmacy does not match the store’s selected pharmacy, order creation will fail (backend: “product does not belong to this pharmacy”). The store switches to the user’s pharmacy when they log in to avoid this.
8. **Member discount vs promo code**: Both can apply to the same order: membership discount is applied when customer_phone matches a customer with a CustomerMembership; promo code discount is then added. Total discount is capped at sub_total. If no customer_phone is sent, membership discount is not applied.
9. **First-order-only promo code**: PromoCode has optional `first_order_only`. When true, validate checks order count for the authenticated user at this pharmacy; if the user has already placed any order, the code returns an error. Validate requires auth so user_id is available; unauthenticated validate (e.g. query) passes userID=nil and first-order-only codes will fail with “please log in”.
10. **Referral & points**: Customer is per pharmacy; same phone in two pharmacies = two customers. Referral reward is credited only on the referred customer’s **first completed** order. Points redeem is applied at order create (balance deducted and PointsTransaction recorded); if order is later cancelled, points are not auto-reverted (future: revert on cancel). Rounding: earn = floor(amount / currency_unit) * points_per_unit; redeem discount = floor(points / rate_points) * rate_currency, capped by order subtotal and max_redeem_per_order.
11. **Subcategory dropdown (Add Product)**: Subcategories are loaded on demand when a parent category is selected. The frontend calls `GET /categories?parent_id=UUID` when the user picks a parent so the subcategory dropdown is populated from the API; the dropdown shows "Select parent first" when no parent is chosen and "Loading…" while fetching. The "Selected" label shows "Parent › Subcategory" when a subcategory is chosen. If a new category is created from the Add Category modal with a parent matching the current selection, the subcategory list is refetched so the new option appears.

---

## Customer attraction (pharmacy & beauty)

- **Promo code at checkout**: Cart/checkout on explore and store pages include a promo code input. User applies a code; frontend calls `POST /promo-codes/validate` with code and sub_total; discount is shown and passed to `POST /orders` as `promo_code`. Backend re-validates at order creation.
- **Rx/OTC and label badges**: Product cards and detail page show a “Prescription” or “OTC” badge from `requires_rx`. Product `labels` (e.g. certified, dermatologist_tested) are shown as small badges on cards (up to 3) and all on detail.
- **Catalog filters**: Public catalog supports `hashtag`, `brand`, `label_key`/`label_value` query params. Frontend filter bar includes inputs for these; “Clear filters” resets them. Hashtag uses JSONB array containment; label uses JSONB key-value containment.
- **Rating on product cards**: Catalog API enriches each product with `rating_avg` and `review_count` from product_reviews. Frontend product cards show star rating and “(N reviews)” when review_count > 0.
- **Recently viewed / You might like**: Recently viewed product IDs are stored in localStorage (max 10). Product detail page adds current product to recent and shows “Recently viewed” (up to 5) and “You might like” (same category, same pharmacy, excluding current, up to 4). Explore page shows “Recently viewed” horizontal strip when non-empty.
- **Pharmacy verified badge**: PharmacyConfig has optional `license_no`, `verified_at`, `established_year`. When `verified_at` is set, the public website header shows a “Verified” badge. Config page (dashboard) includes “Trust & verification” section to set these.
- **First-order-only promo**: PromoCode has `first_order_only`. When set, validate fails if the authenticated user has any prior order at this pharmacy. Cart shows hint “First order? Try a welcome code if you have one.”
- **Promo end date on What’s on**: “What’s on” promo cards display “Offer ends &lt;date&gt;” (or “Starts &lt;date&gt;”) when `end_at` or `start_at` is set.

---

## Performance Optimizations

- Backend: GORM connection pool (MaxIdleConns, MaxOpenConns, ConnMaxLifetime). Zap for structured logging; log level can be tuned per environment.
- Frontend: Vite for fast HMR and builds. No heavy dependencies. Product lists use pagination (limit/offset) so 18+ products load one page at a time; dashboard default 10 per page, store 12 per page.

---

## User Feedback Incorporation

- Initial scope focused on pharmacy management, products, orders, and payments as requested. Auth and role model kept simple (single pharmacy, role string) so it can be extended (e.g. permissions per role) based on feedback.
- README and this document describe bootstrap and first-use flow so that “how do I create the first pharmacy/user?” is documented.

---

## Unit testing (no database)

- **Domain services** are tested with mocks only (no DB, no real JWT). Mocks live in `internal/mocks/outbound`: hand-written stubs for `UserRepository`, `PharmacyRepository`, `ProductRepository`, and `AuthProvider`. Tests set `*Func` fields to control return values.
- **Tests**: `internal/domain/services/*_test.go` cover `AuthService` (Register, Login, GetCurrentUser, conflict/not-found paths), `PharmacyService` (Create, GetByID, List, Update, validation), and `ProductService` (Create, GetByID, List, UpdateStock, Delete, validation/SKU conflict).
- **mockgen**: Optional. `//go:generate` directives in `internal/ports/outbound` allow regenerating mocks with `go generate ./internal/ports/outbound/...` when mockgen is installed. Hand-written mocks are used by default so tests run without network/tools.

---

## Seeder & Quick Login (demo)

- **Backend**: `go run ./cmd/seed` creates one demo pharmacy and four users (same password `password123`): **admin@careplus.com** (Admin), **pharmacist@careplus.com** (Pharmacist), **buyer@careplus.com** (End user / staff), and **test@careplus.com** (Admin, legacy). All belong to the same demo pharmacy.
- **Frontend**: Login page has "Quick login (demo)" buttons for Admin, Pharmacist, and End user (Buyer). Each button logs in with the corresponding seeded account so different roles can be tried without typing credentials.

---

## Analytics sidebar (planned)

- **Plan:** See `docs/ANALYTICS_SIDEBAR_PLAN.md` for the full backend and frontend plan.
- **Purpose:** Dedicated analytics page (or collapsible sidebar) for managers and stakeholders with charts and KPIs.
- **Time ranges:** Today, weekly, monthly, quarterly, yearly, custom date range (query params `from`, `to`, `period`).
- **Charts:** Bar (revenue/orders by period, by category, top products), line (revenue/orders over time), trend (growth vs previous period), heatmap (activity by hour × day), pie (revenue by category, orders by status, payment methods), plus KPI summary cards.
- **Backend:** New `AnalyticsService` and handler; endpoints under `GET /api/v1/analytics/*` (summary, revenue-by-period, orders-by-period, revenue-by-category, top-products, revenue-over-time, orders-over-time, trend, heatmap, orders-by-status, payment-methods); pharmacy-scoped; optional `RequireAdminOrManager()`.
- **Frontend:** Route `/analytics`, date range selector (presets + custom), Recharts for charts, `analyticsApi` in `lib/api.ts`, sidebar entry for admin/manager.

---

## Possible Next Steps

- Pagination and filters for orders (products pagination done; orders could follow same pattern).
- Order cancellation with stock restoration.
- Payment refunds or partial payments.
- Prescription/repeat script tracking if required.
- Audit log for sensitive actions (e.g. payment complete, order status change).
- **Analytics:** Implement analytics sidebar per `docs/ANALYTICS_SIDEBAR_PLAN.md`.

---

## Activity logs

- **Purpose**: Maintain a feed of API activity per pharmacy so staff can see who did what and when.
- **Backend**: `ActivityLog` model (id, pharmacy_id, user_id, action, entity_type, entity_id, details, ip_address, created_at). Action is stored as `METHOD path` (e.g. `GET /orders`, `POST /products`). `ActivityLogRepository` (Create, ListByPharmacy with limit/offset), `ActivityLogService` (Create, ListByPharmacy), `ActivityHandler` (GET `/api/v1/activity`). Activity is recorded by middleware: after Auth, every authenticated request is logged (method + path, user, pharmacy, IP). Table `activity_logs` is created via AutoMigrate.
- **Frontend**: "Activity" link in the sidebar (lucide-react Activity icon), route `/activity`, `ActivityPage` that fetches `GET /api/v1/activity` and displays a table of time, user, action, IP. `activityApi.list()` in `lib/api.ts` with optional limit/offset.
- **Edge case**: Logging is best-effort; if Create fails we log at debug and do not fail the request. List is scoped to the current pharmacy from JWT.
- Seed script or “setup wizard” for first pharmacy and admin user.
